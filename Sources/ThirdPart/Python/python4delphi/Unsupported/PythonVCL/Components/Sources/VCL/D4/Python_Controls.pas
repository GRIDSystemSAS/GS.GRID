////
//  This file was generated by VCL Generator
//  Copyright 1998 - Morgan Martinet
//  06/07/1999 07:58:52
//  it declares the content of the module _Controls
////

unit Python_Controls;

interface

uses
   Windows,
   Graphics,
   Menus,
   ImgList,
   ActnList,
   Controls,
   Messages,
   Classes,
   SysUtils,
   PythonEngine;

type
  TModule_Controls = class( TPythonModule )
  public
    procedure Initialize; override;
  end;

  function TDragObject_ReadAttribute( Self : TDragObject; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TDragObject_WriteAttribute( Self : TDragObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TBaseDragControlObject_ReadAttribute( Self : TBaseDragControlObject; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TBaseDragControlObject_WriteAttribute( Self : TBaseDragControlObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TDragControlObject_ReadAttribute( Self : TDragControlObject; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TDragControlObject_WriteAttribute( Self : TDragControlObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TDragDockObject_ReadAttribute( Self : TDragDockObject; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TDragDockObject_WriteAttribute( Self : TDragDockObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TControlCanvas_ReadAttribute( Self : TControlCanvas; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TControlCanvas_WriteAttribute( Self : TControlCanvas; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TControlActionLink_ReadAttribute( Self : TControlActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TControlActionLink_WriteAttribute( Self : TControlActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TSizeConstraints_ReadAttribute( Self : TSizeConstraints; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TSizeConstraints_WriteAttribute( Self : TSizeConstraints; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TControl_ReadAttribute( Self : TControl; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TControl_WriteAttribute( Self : TControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TWinControlActionLink_ReadAttribute( Self : TWinControlActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TWinControlActionLink_WriteAttribute( Self : TWinControlActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TWinControl_ReadAttribute( Self : TWinControl; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TWinControl_WriteAttribute( Self : TWinControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TGraphicControl_ReadAttribute( Self : TGraphicControl; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TGraphicControl_WriteAttribute( Self : TGraphicControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCustomControl_ReadAttribute( Self : TCustomControl; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCustomControl_WriteAttribute( Self : TCustomControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function THintWindow_ReadAttribute( Self : THintWindow; argSelf : PPyObject; key : PChar ) : PPyObject;
  function THintWindow_WriteAttribute( Self : THintWindow; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TDragImageList_ReadAttribute( Self : TDragImageList; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TDragImageList_WriteAttribute( Self : TDragImageList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TImageList_ReadAttribute( Self : TImageList; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TImageList_WriteAttribute( Self : TImageList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TDockZone_ReadAttribute( Self : TDockZone; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TDockZone_WriteAttribute( Self : TDockZone; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TDockTree_ReadAttribute( Self : TDockTree; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TDockTree_WriteAttribute( Self : TDockTree; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TMouse_ReadAttribute( Self : TMouse; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMouse_WriteAttribute( Self : TMouse; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;

  procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 

implementation

uses
   Delphi_Classes,
   Python_Classes,
   Delphi_Graphics,
   Python_Graphics,
   Delphi_Menus,
   Python_Menus,
   Delphi_ImgList,
   Python_ImgList,
   Delphi_ActnList,
   Python_ActnList,
   Delphi_System,
   Delphi_Controls,
   Python_System,
   Py_Misc,
   PyRecords,
   PyDelphiAssoc;

var
  IsInitialized : Boolean;
  gControls : TModule_Controls;
  gTDragObject : TMethodsContainer;
  gTBaseDragControlObject : TMethodsContainer;
  gTDragControlObject : TMethodsContainer;
  gTDragDockObject : TMethodsContainer;
  gTControlCanvas : TMethodsContainer;
  gTControlActionLink : TMethodsContainer;
  gTSizeConstraints : TMethodsContainer;
  gTControl : TMethodsContainer;
  gTWinControlActionLink : TMethodsContainer;
  gTWinControl : TMethodsContainer;
  gTGraphicControl : TMethodsContainer;
  gTCustomControl : TMethodsContainer;
  gTHintWindow : TMethodsContainer;
  gTDragImageList : TMethodsContainer;
  gTImageList : TMethodsContainer;
  gTDockZone : TMethodsContainer;
  gTDockTree : TMethodsContainer;
  gTMouse : TMethodsContainer;

procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 
begin
  if IsInitialized then
    Exit;
  IsInitialized := True;
  gControls := TModule_Controls.Create( AOwner );
  with gControls do
    begin
      Engine := AEngine;
      ModuleName := '_Controls';
    end;
  gTDragObject := TMethodsContainer.Create( AOwner );
  gTBaseDragControlObject := TMethodsContainer.Create( AOwner );
  gTDragControlObject := TMethodsContainer.Create( AOwner );
  gTDragDockObject := TMethodsContainer.Create( AOwner );
  gTControlCanvas := TMethodsContainer.Create( AOwner );
  gTControlActionLink := TMethodsContainer.Create( AOwner );
  gTSizeConstraints := TMethodsContainer.Create( AOwner );
  gTControl := TMethodsContainer.Create( AOwner );
  gTWinControlActionLink := TMethodsContainer.Create( AOwner );
  gTWinControl := TMethodsContainer.Create( AOwner );
  gTGraphicControl := TMethodsContainer.Create( AOwner );
  gTCustomControl := TMethodsContainer.Create( AOwner );
  gTHintWindow := TMethodsContainer.Create( AOwner );
  gTDragImageList := TMethodsContainer.Create( AOwner );
  gTImageList := TMethodsContainer.Create( AOwner );
  gTDockZone := TMethodsContainer.Create( AOwner );
  gTDockTree := TMethodsContainer.Create( AOwner );
  gTMouse := TMethodsContainer.Create( AOwner );
end;

///////////// Functions for class TDragObject //////////////////

function TDragObject_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDragObject;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TDragObject.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDragObject.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDragObject_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    // Check attribute
    Result := TDragObject_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TDragObject_ReadAttribute( Self : TDragObject; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTDragObject.MethodCount > 0 then 
      Result := Py_FindMethod( gTDragObject.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Cancelling' ) = 0 then Result := VariantAsPyObject( Self.Cancelling )
    else if CompareText( key, 'DragHandle' ) = 0 then Result := VariantAsPyObject( Self.DragHandle )
    else if CompareText( key, 'DragPos' ) = 0 then Result := CreatePoint( Self.DragPos ).GetSelf
    else if CompareText( key, 'DragTargetPos' ) = 0 then Result := CreatePoint( Self.DragTargetPos ).GetSelf
    else if CompareText( key, 'DragTarget' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'Pointer' ); Result := nil; end
    else if CompareText( key, 'MouseDeltaX' ) = 0 then Result := VariantAsPyObject( Self.MouseDeltaX )
    else if CompareText( key, 'MouseDeltaY' ) = 0 then Result := VariantAsPyObject( Self.MouseDeltaY )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TDragObject_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    // Check attribute
    Result := TDragObject_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TDragObject_WriteAttribute( Self : TDragObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Cancelling' ) = 0 then begin
      Self.Cancelling := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragHandle' ) = 0 then begin
      Self.DragHandle := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragPos' ) = 0 then begin
      Self.DragPos := PyObjectAsPoint( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragTargetPos' ) = 0 then begin
      Self.DragTargetPos := PyObjectAsPoint( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragTarget' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'Pointer' );
    end else if CompareText( key, 'MouseDeltaX' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'MouseDeltaY' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TDragObject_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragObject;
  _argSource : PPyObject;
  _objSource : TDragObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TDragObject.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TDragObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( Self, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TDragObject_GetName( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragObject;
  rslt : string;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( Self, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    rslt := realObj.GetName;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TDragObject_HideDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( Self, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    realObj.HideDragImage;
    Result := ReturnNone;
  end;
end;

function TDragObject_Instance( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragObject;
  rslt : THandle;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( Self, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    rslt := realObj.Instance;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TDragObject_ShowDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragObject) then begin
      ErrorWrongExpectedType( Self, 'TDragObject' );
      Exit;
    end;
    realObj := TDragObject(obj);
    realObj.ShowDragImage;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TBaseDragControlObject //////////////////

function TBaseDragControlObject_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyBaseDragControlObject;
  _argSelf : PPyObject;
  _argAControl : PPyObject;
  _objAControl : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TBaseDragControlObject.Create', [ @_argSelf,
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyBaseDragControlObject.Create( _objAControl );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TBaseDragControlObject_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBaseDragControlObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBaseDragControlObject) then begin
      ErrorWrongExpectedType( argSelf, 'TBaseDragControlObject' );
      Exit;
    end;
    realObj := TBaseDragControlObject(obj);
    // Check attribute
    Result := TBaseDragControlObject_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TBaseDragControlObject_ReadAttribute( Self : TBaseDragControlObject; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTBaseDragControlObject.MethodCount > 0 then 
      Result := Py_FindMethod( gTBaseDragControlObject.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Control' ) = 0 then Result := GetPythonObject( Self.Control, 'Controls', 'TControl' )
    else Result := TDragObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TBaseDragControlObject_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBaseDragControlObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBaseDragControlObject) then begin
      ErrorWrongExpectedType( argSelf, 'TBaseDragControlObject' );
      Exit;
    end;
    realObj := TBaseDragControlObject(obj);
    // Check attribute
    Result := TBaseDragControlObject_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TBaseDragControlObject_WriteAttribute( Self : TBaseDragControlObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Control' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TControl then begin
        Self.Control := TControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Control', 'TControl' );
    end else Result := TDragObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TBaseDragControlObject_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBaseDragControlObject;
  _argSource : PPyObject;
  _objSource : TDragObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBaseDragControlObject.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TDragObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBaseDragControlObject) then begin
      ErrorWrongExpectedType( Self, 'TBaseDragControlObject' );
      Exit;
    end;
    realObj := TBaseDragControlObject(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TDragControlObject //////////////////

function TDragControlObject_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDragControlObject;
  _argSelf : PPyObject;
  _argAControl : PPyObject;
  _objAControl : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TDragControlObject.Create', [ @_argSelf,
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDragControlObject.Create( _objAControl );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDragControlObject_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragControlObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragControlObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragControlObject' );
      Exit;
    end;
    realObj := TDragControlObject(obj);
    // Check attribute
    Result := TDragControlObject_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TDragControlObject_ReadAttribute( Self : TDragControlObject; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTDragControlObject.MethodCount > 0 then 
      Result := Py_FindMethod( gTDragControlObject.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TBaseDragControlObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TDragControlObject_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragControlObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragControlObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragControlObject' );
      Exit;
    end;
    realObj := TDragControlObject(obj);
    // Check attribute
    Result := TDragControlObject_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TDragControlObject_WriteAttribute( Self : TDragControlObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TBaseDragControlObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TDragControlObject_HideDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragControlObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragControlObject) then begin
      ErrorWrongExpectedType( Self, 'TDragControlObject' );
      Exit;
    end;
    realObj := TDragControlObject(obj);
    realObj.HideDragImage;
    Result := ReturnNone;
  end;
end;

function TDragControlObject_ShowDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragControlObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragControlObject) then begin
      ErrorWrongExpectedType( Self, 'TDragControlObject' );
      Exit;
    end;
    realObj := TDragControlObject(obj);
    realObj.ShowDragImage;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TDragDockObject //////////////////

function TDragDockObject_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDragDockObject;
  _argSelf : PPyObject;
  _argAControl : PPyObject;
  _objAControl : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TDragDockObject.Create', [ @_argSelf,
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDragDockObject.Create( _objAControl );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDragDockObject_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragDockObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragDockObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragDockObject' );
      Exit;
    end;
    realObj := TDragDockObject(obj);
    // Check attribute
    Result := TDragDockObject_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TDragDockObject_ReadAttribute( Self : TDragDockObject; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTDragDockObject.MethodCount > 0 then 
      Result := Py_FindMethod( gTDragDockObject.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Brush' ) = 0 then Result := GetPythonObject( Self.Brush, 'Controls', 'TBrush' )
    else if CompareText( key, 'DockRect' ) = 0 then Result := CreateRect( Self.DockRect ).GetSelf
    else if CompareText( key, 'DropAlign' ) = 0 then Result := VariantAsPyObject( Integer( Self.DropAlign ) )
    else if CompareText( key, 'DropOnControl' ) = 0 then Result := GetPythonObject( Self.DropOnControl, 'Controls', 'TControl' )
    else if CompareText( key, 'Floating' ) = 0 then Result := VariantAsPyObject( Self.Floating )
    else if CompareText( key, 'FrameWidth' ) = 0 then Result := VariantAsPyObject( Self.FrameWidth )
    else Result := TBaseDragControlObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TDragDockObject_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragDockObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragDockObject) then begin
      ErrorWrongExpectedType( argSelf, 'TDragDockObject' );
      Exit;
    end;
    realObj := TDragDockObject(obj);
    // Check attribute
    Result := TDragDockObject_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TDragDockObject_WriteAttribute( Self : TDragDockObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Brush' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBrush then begin
        Self.Brush := TBrush( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Brush', 'TBrush' );
    end else if CompareText( key, 'DockRect' ) = 0 then begin
      Self.DockRect := PyObjectAsRect( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DropAlign' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DropOnControl' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Floating' ) = 0 then begin
      Self.Floating := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'FrameWidth' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TBaseDragControlObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TDragDockObject_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragDockObject;
  _argSource : PPyObject;
  _objSource : TDragObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TDragDockObject.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TDragObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragDockObject) then begin
      ErrorWrongExpectedType( Self, 'TDragDockObject' );
      Exit;
    end;
    realObj := TDragDockObject(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TControlCanvas //////////////////

function TControlCanvas_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyControlCanvas;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TControlCanvas.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyControlCanvas.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TControlCanvas_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControlCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControlCanvas) then begin
      ErrorWrongExpectedType( argSelf, 'TControlCanvas' );
      Exit;
    end;
    realObj := TControlCanvas(obj);
    // Check attribute
    Result := TControlCanvas_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TControlCanvas_ReadAttribute( Self : TControlCanvas; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTControlCanvas.MethodCount > 0 then 
      Result := Py_FindMethod( gTControlCanvas.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Control' ) = 0 then Result := GetPythonObject( Self.Control, 'Controls', 'TControl' )
    else Result := TCanvas_ReadAttribute( Self, argSelf, key );
  end;
end;

function TControlCanvas_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControlCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControlCanvas) then begin
      ErrorWrongExpectedType( argSelf, 'TControlCanvas' );
      Exit;
    end;
    realObj := TControlCanvas(obj);
    // Check attribute
    Result := TControlCanvas_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TControlCanvas_WriteAttribute( Self : TControlCanvas; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Control' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TControl then begin
        Self.Control := TControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Control', 'TControl' );
    end else Result := TCanvas_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TControlCanvas_FreeHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControlCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControlCanvas) then begin
      ErrorWrongExpectedType( Self, 'TControlCanvas' );
      Exit;
    end;
    realObj := TControlCanvas(obj);
    realObj.FreeHandle;
    Result := ReturnNone;
  end;
end;

function TControlCanvas_UpdateTextFlags( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControlCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControlCanvas) then begin
      ErrorWrongExpectedType( Self, 'TControlCanvas' );
      Exit;
    end;
    realObj := TControlCanvas(obj);
    realObj.UpdateTextFlags;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TControlActionLink //////////////////

function TControlActionLink_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyControlActionLink;
  _argSelf : PPyObject;
  _argAClient : PPyObject;
  _objAClient : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TControlActionLink.Create', [ @_argSelf,
                  @_argAClient       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAClient := GetObjectOf( _argAClient ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyControlActionLink.Create( _objAClient );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TControlActionLink_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControlActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControlActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TControlActionLink' );
      Exit;
    end;
    realObj := TControlActionLink(obj);
    // Check attribute
    Result := TControlActionLink_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TControlActionLink_ReadAttribute( Self : TControlActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTControlActionLink.MethodCount > 0 then 
      Result := Py_FindMethod( gTControlActionLink.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TActionLink_ReadAttribute( Self, argSelf, key );
  end;
end;

function TControlActionLink_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControlActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControlActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TControlActionLink' );
      Exit;
    end;
    realObj := TControlActionLink(obj);
    // Check attribute
    Result := TControlActionLink_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TControlActionLink_WriteAttribute( Self : TControlActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TActionLink_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TSizeConstraints //////////////////

function TSizeConstraints_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPySizeConstraints;
  _argSelf : PPyObject;
  _argControl : PPyObject;
  _objControl : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TSizeConstraints.Create', [ @_argSelf,
                  @_argControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objControl := GetObjectOf( _argControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPySizeConstraints.Create( _objControl );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TSizeConstraints_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TSizeConstraints;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TSizeConstraints) then begin
      ErrorWrongExpectedType( argSelf, 'TSizeConstraints' );
      Exit;
    end;
    realObj := TSizeConstraints(obj);
    // Check attribute
    Result := TSizeConstraints_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TSizeConstraints_ReadAttribute( Self : TSizeConstraints; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTSizeConstraints.MethodCount > 0 then 
      Result := Py_FindMethod( gTSizeConstraints.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'MaxHeight' ) = 0 then Result := VariantAsPyObject( Integer( Self.MaxHeight ) )
    else if CompareText( key, 'MaxWidth' ) = 0 then Result := VariantAsPyObject( Integer( Self.MaxWidth ) )
    else if CompareText( key, 'MinHeight' ) = 0 then Result := VariantAsPyObject( Integer( Self.MinHeight ) )
    else if CompareText( key, 'MinWidth' ) = 0 then Result := VariantAsPyObject( Integer( Self.MinWidth ) )
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TSizeConstraints_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TSizeConstraints;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TSizeConstraints) then begin
      ErrorWrongExpectedType( argSelf, 'TSizeConstraints' );
      Exit;
    end;
    realObj := TSizeConstraints(obj);
    // Check attribute
    Result := TSizeConstraints_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TSizeConstraints_WriteAttribute( Self : TSizeConstraints; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPySizeConstraints then
          with TPySizeConstraints(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'MaxHeight' ) = 0 then begin
      Self.MaxHeight := TConstraintSize(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MaxWidth' ) = 0 then begin
      Self.MaxWidth := TConstraintSize(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MinHeight' ) = 0 then begin
      Self.MinHeight := TConstraintSize(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MinWidth' ) = 0 then begin
      Self.MinWidth := TConstraintSize(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TControl //////////////////

function TControl_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyControl;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TControl.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyControl.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TControl_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( argSelf, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    // Check attribute
    Result := TControl_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TControl_ReadAttribute( Self : TControl; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpAnchors : TAnchors;
  tmpControlState : TControlState;
  tmpControlStyle : TControlStyle;
begin
  with GetPythonEngine do begin
    if gTControl.MethodCount > 0 then 
      Result := Py_FindMethod( gTControl.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Enabled' ) = 0 then Result := VariantAsPyObject( Self.Enabled )
    else if CompareText( key, 'Action' ) = 0 then Result := GetPythonObject( Self.Action, 'Controls', 'TBasicAction' )
    else if CompareText( key, 'Align' ) = 0 then Result := VariantAsPyObject( Integer( Self.Align ) )
    else if CompareText( key, 'Anchors' ) = 0 then begin
      tmpAnchors := Self.Anchors;
      Result := SetToList( @tmpAnchors, sizeof(tmpAnchors) )
    end
    else if CompareText( key, 'BiDiMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.BiDiMode ) )
    else if CompareText( key, 'BoundsRect' ) = 0 then Result := CreateRect( Self.BoundsRect ).GetSelf
    else if CompareText( key, 'ClientHeight' ) = 0 then Result := VariantAsPyObject( Self.ClientHeight )
    else if CompareText( key, 'ClientOrigin' ) = 0 then Result := CreatePoint( Self.ClientOrigin ).GetSelf
    else if CompareText( key, 'ClientRect' ) = 0 then Result := CreateRect( Self.ClientRect ).GetSelf
    else if CompareText( key, 'ClientWidth' ) = 0 then Result := VariantAsPyObject( Self.ClientWidth )
    else if CompareText( key, 'Constraints' ) = 0 then Result := GetPythonObject( Self.Constraints, 'Controls', 'TSizeConstraints' )
    else if CompareText( key, 'ControlState' ) = 0 then begin
      tmpControlState := Self.ControlState;
      Result := SetToList( @tmpControlState, sizeof(tmpControlState) )
    end
    else if CompareText( key, 'ControlStyle' ) = 0 then begin
      tmpControlStyle := Self.ControlStyle;
      Result := SetToList( @tmpControlStyle, sizeof(tmpControlStyle) )
    end
    else if CompareText( key, 'DockOrientation' ) = 0 then Result := VariantAsPyObject( Integer( Self.DockOrientation ) )
    else if CompareText( key, 'Floating' ) = 0 then Result := VariantAsPyObject( Self.Floating )
    else if CompareText( key, 'FloatingDockSiteClass' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TWinControlClass' ); Result := nil; end
    else if CompareText( key, 'HostDockSite' ) = 0 then Result := GetPythonObject( Self.HostDockSite, 'Controls', 'TWinControl' )
    else if CompareText( key, 'LRDockWidth' ) = 0 then Result := VariantAsPyObject( Self.LRDockWidth )
    else if CompareText( key, 'Parent' ) = 0 then Result := GetPythonObject( Self.Parent, 'Controls', 'TWinControl' )
    else if CompareText( key, 'ShowHint' ) = 0 then Result := VariantAsPyObject( Self.ShowHint )
    else if CompareText( key, 'TBDockHeight' ) = 0 then Result := VariantAsPyObject( Self.TBDockHeight )
    else if CompareText( key, 'UndockHeight' ) = 0 then Result := VariantAsPyObject( Self.UndockHeight )
    else if CompareText( key, 'UndockWidth' ) = 0 then Result := VariantAsPyObject( Self.UndockWidth )
    else if CompareText( key, 'Visible' ) = 0 then Result := VariantAsPyObject( Self.Visible )
    else if CompareText( key, 'WindowProc' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TWndMethod' ); Result := nil; end
    else if CompareText( key, 'Left' ) = 0 then Result := VariantAsPyObject( Self.Left )
    else if CompareText( key, 'Top' ) = 0 then Result := VariantAsPyObject( Self.Top )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'Cursor' ) = 0 then Result := VariantAsPyObject( Integer( Self.Cursor ) )
    else if CompareText( key, 'Hint' ) = 0 then Result := VariantAsPyObject( Self.Hint )
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TControl_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( argSelf, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    // Check attribute
    Result := TControl_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TControl_WriteAttribute( Self : TControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpAnchors : TAnchors;
  tmpControlState : TControlState;
  tmpControlStyle : TControlStyle;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Enabled' ) = 0 then begin
      Self.Enabled := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Action' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBasicAction then begin
        Self.Action := TBasicAction( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Action', 'TBasicAction' );
    end else if CompareText( key, 'Align' ) = 0 then begin
      Self.Align := TAlign(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Anchors' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpAnchors, sizeof(tmpAnchors) );
        Self.Anchors := tmpAnchors;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Anchors', 'TAnchors' );
    end else if CompareText( key, 'BiDiMode' ) = 0 then begin
      Self.BiDiMode := TBiDiMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BoundsRect' ) = 0 then begin
      Self.BoundsRect := PyObjectAsRect( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ClientHeight' ) = 0 then begin
      Self.ClientHeight := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ClientOrigin' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ClientRect' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ClientWidth' ) = 0 then begin
      Self.ClientWidth := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Constraints' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TSizeConstraints then begin
        Self.Constraints := TSizeConstraints( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Constraints', 'TSizeConstraints' );
    end else if CompareText( key, 'ControlState' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpControlState, sizeof(tmpControlState) );
        Self.ControlState := tmpControlState;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'ControlState', 'TControlState' );
    end else if CompareText( key, 'ControlStyle' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpControlStyle, sizeof(tmpControlStyle) );
        Self.ControlStyle := tmpControlStyle;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'ControlStyle', 'TControlStyle' );
    end else if CompareText( key, 'DockOrientation' ) = 0 then begin
      Self.DockOrientation := TDockOrientation(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Floating' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'FloatingDockSiteClass' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'TWinControlClass' );
    end else if CompareText( key, 'HostDockSite' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TWinControl then begin
        Self.HostDockSite := TWinControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'HostDockSite', 'TWinControl' );
    end else if CompareText( key, 'LRDockWidth' ) = 0 then begin
      Self.LRDockWidth := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Parent' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TWinControl then begin
        Self.Parent := TWinControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Parent', 'TWinControl' );
    end else if CompareText( key, 'ShowHint' ) = 0 then begin
      Self.ShowHint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'TBDockHeight' ) = 0 then begin
      Self.TBDockHeight := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'UndockHeight' ) = 0 then begin
      Self.UndockHeight := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'UndockWidth' ) = 0 then begin
      Self.UndockWidth := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Visible' ) = 0 then begin
      Self.Visible := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'WindowProc' ) = 0 then begin
      if Value = Py_None then begin
        Self.WindowProc := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyControl then
          with TPyControl(Self) do
            WindowProc := EventWindowProc;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'Left' ) = 0 then begin
      Self.Left := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Top' ) = 0 then begin
      Self.Top := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Width' ) = 0 then begin
      Self.Width := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Height' ) = 0 then begin
      Self.Height := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Cursor' ) = 0 then begin
      Self.Cursor := TCursor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Hint' ) = 0 then begin
      Self.Hint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TControl_BeginDrag( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argImmediate : Integer;
  _argThreshold : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TControl.BeginDrag', [ 
                  @_argImmediate,
                  @_argThreshold       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.BeginDrag( Boolean(_argImmediate), Integer(_argThreshold) );
    Result := ReturnNone;
  end;
end;

function TControl_BringToFront( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.BringToFront;
    Result := ReturnNone;
  end;
end;

function TControl_ClientToScreen( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : TPoint;
  _argPoint : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TControl.ClientToScreen', [ 
                  @_argPoint       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.ClientToScreen( PyObjectAsPoint( _argPoint ) );
    Result := CreatePoint( rslt ).GetSelf;
  end;
end;

function TControl_Dock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argNewDockSite : PPyObject;
  _objNewDockSite : TWinControl;
  _argARect : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OO:TControl.Dock', [ 
                  @_argNewDockSite,
                  @_argARect       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objNewDockSite := GetObjectOf( _argNewDockSite ) as TWinControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Dock( _objNewDockSite, PyObjectAsRect( _argARect ) );
    Result := ReturnNone;
  end;
end;

function TControl_DefaultHandler( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TControl_Dragging( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.Dragging;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_DragDrop( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argSource : PPyObject;
  _objSource : TObject;
  _argX : Integer;
  _argY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oii:TControl.DragDrop', [ 
                  @_argSource,
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.DragDrop( _objSource, Integer(_argX), Integer(_argY) );
    Result := ReturnNone;
  end;
end;

function TControl_DrawTextBiDiModeFlags( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Longint;
  _argFlags : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TControl.DrawTextBiDiModeFlags', [ 
                  @_argFlags       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.DrawTextBiDiModeFlags( Longint(_argFlags) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_DrawTextBiDiModeFlagsReadingOnly( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Longint;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.DrawTextBiDiModeFlagsReadingOnly;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_EndDrag( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argDrop : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TControl.EndDrag', [ 
                  @_argDrop       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.EndDrag( Boolean(_argDrop) );
    Result := ReturnNone;
  end;
end;

function TControl_GetControlsAlignment( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : TAlignment;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.GetControlsAlignment;
    Result := VariantAsPyObject( Integer( rslt ) );
  end;
end;

function TControl_GetParentComponent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.GetParentComponent;
    Result := GetPythonObject( rslt, 'Controls', 'TComponent' );
  end;
end;

function TControl_GetTextBuf( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Integer;
  _argBuffer : PChar;
  _argBufSize : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'si:TControl.GetTextBuf', [ 
                  @_argBuffer,
                  @_argBufSize       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.GetTextBuf( PChar(_argBuffer), Integer(_argBufSize) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_GetTextLen( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.GetTextLen;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_HasParent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.HasParent;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_Hide( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Hide;
    Result := ReturnNone;
  end;
end;

function TControl_InitiateAction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.InitiateAction;
    Result := ReturnNone;
  end;
end;

function TControl_Invalidate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Invalidate;
    Result := ReturnNone;
  end;
end;

function TControl_IsRightToLeft( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.IsRightToLeft;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_ManualDock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
  _argNewDockSite : PPyObject;
  _objNewDockSite : TWinControl;
  _argDropControl : PPyObject;
  _objDropControl : TControl;
  _argControlSide : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OOi:TControl.ManualDock', [ 
                  @_argNewDockSite,
                  @_argDropControl,
                  @_argControlSide       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objNewDockSite := GetObjectOf( _argNewDockSite ) as TWinControl;
    _objDropControl := GetObjectOf( _argDropControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.ManualDock( _objNewDockSite, _objDropControl, TAlign(_argControlSide) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_ManualFloat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
  _argScreenPos : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TControl.ManualFloat', [ 
                  @_argScreenPos       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.ManualFloat( PyObjectAsRect( _argScreenPos ) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_Perform( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Longint;
  _argMsg : Integer;
  _argWParam : Integer;
  _argLParam : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TControl.Perform', [ 
                  @_argMsg,
                  @_argWParam,
                  @_argLParam       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.Perform( Cardinal(_argMsg), Longint(_argWParam), Longint(_argLParam) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_Refresh( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Refresh;
    Result := ReturnNone;
  end;
end;

function TControl_Repaint( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Repaint;
    Result := ReturnNone;
  end;
end;

function TControl_ReplaceDockedControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
  _argControl : PPyObject;
  _objControl : TControl;
  _argNewDockSite : PPyObject;
  _objNewDockSite : TWinControl;
  _argDropControl : PPyObject;
  _objDropControl : TControl;
  _argControlSide : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OOOi:TControl.ReplaceDockedControl', [ 
                  @_argControl,
                  @_argNewDockSite,
                  @_argDropControl,
                  @_argControlSide       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objControl := GetObjectOf( _argControl ) as TControl;
    _objNewDockSite := GetObjectOf( _argNewDockSite ) as TWinControl;
    _objDropControl := GetObjectOf( _argDropControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.ReplaceDockedControl( _objControl, _objNewDockSite, _objDropControl, TAlign(_argControlSide) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_ScreenToClient( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : TPoint;
  _argPoint : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TControl.ScreenToClient', [ 
                  @_argPoint       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.ScreenToClient( PyObjectAsPoint( _argPoint ) );
    Result := CreatePoint( rslt ).GetSelf;
  end;
end;

function TControl_SendToBack( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.SendToBack;
    Result := ReturnNone;
  end;
end;

function TControl_SetBounds( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argALeft : Integer;
  _argATop : Integer;
  _argAWidth : Integer;
  _argAHeight : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiii:TControl.SetBounds', [ 
                  @_argALeft,
                  @_argATop,
                  @_argAWidth,
                  @_argAHeight       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.SetBounds( Integer(_argALeft), Integer(_argATop), Integer(_argAWidth), Integer(_argAHeight) );
    Result := ReturnNone;
  end;
end;

function TControl_SetTextBuf( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  _argBuffer : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TControl.SetTextBuf', [ 
                  @_argBuffer       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.SetTextBuf( PChar(_argBuffer) );
    Result := ReturnNone;
  end;
end;

function TControl_Show( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Show;
    Result := ReturnNone;
  end;
end;

function TControl_Update( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    realObj.Update;
    Result := ReturnNone;
  end;
end;

function TControl_UseRightToLeftAlignment( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.UseRightToLeftAlignment;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_UseRightToLeftReading( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.UseRightToLeftReading;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TControl_UseRightToLeftScrollBar( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControl;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControl) then begin
      ErrorWrongExpectedType( Self, 'TControl' );
      Exit;
    end;
    realObj := TControl(obj);
    rslt := realObj.UseRightToLeftScrollBar;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TWinControlActionLink //////////////////

function TWinControlActionLink_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyWinControlActionLink;
  _argSelf : PPyObject;
  _argAClient : PPyObject;
  _objAClient : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TWinControlActionLink.Create', [ @_argSelf,
                  @_argAClient       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAClient := GetObjectOf( _argAClient ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyWinControlActionLink.Create( _objAClient );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TWinControlActionLink_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TWinControlActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControlActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TWinControlActionLink' );
      Exit;
    end;
    realObj := TWinControlActionLink(obj);
    // Check attribute
    Result := TWinControlActionLink_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TWinControlActionLink_ReadAttribute( Self : TWinControlActionLink; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTWinControlActionLink.MethodCount > 0 then 
      Result := Py_FindMethod( gTWinControlActionLink.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TControlActionLink_ReadAttribute( Self, argSelf, key );
  end;
end;

function TWinControlActionLink_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TWinControlActionLink;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControlActionLink) then begin
      ErrorWrongExpectedType( argSelf, 'TWinControlActionLink' );
      Exit;
    end;
    realObj := TWinControlActionLink(obj);
    // Check attribute
    Result := TWinControlActionLink_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TWinControlActionLink_WriteAttribute( Self : TWinControlActionLink; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TControlActionLink_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TWinControl //////////////////

function TWinControl_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyWinControl;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TWinControl.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyWinControl.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TWinControl_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyWinControl;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TWinControl.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyWinControl.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TWinControl_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( argSelf, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    // Check attribute
    Result := TWinControl_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TWinControl_ReadAttribute( Self : TWinControl; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTWinControl.MethodCount > 0 then 
      Result := Py_FindMethod( gTWinControl.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'DockClientCount' ) = 0 then Result := VariantAsPyObject( Self.DockClientCount )
    else if CompareText( key, 'DoubleBuffered' ) = 0 then Result := VariantAsPyObject( Self.DoubleBuffered )
    else if CompareText( key, 'Brush' ) = 0 then Result := GetPythonObject( Self.Brush, 'Controls', 'TBrush' )
    else if CompareText( key, 'ControlCount' ) = 0 then Result := VariantAsPyObject( Self.ControlCount )
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else if CompareText( key, 'ParentWindow' ) = 0 then Result := VariantAsPyObject( Self.ParentWindow )
    else if CompareText( key, 'Showing' ) = 0 then Result := VariantAsPyObject( Self.Showing )
    else if CompareText( key, 'TabOrder' ) = 0 then Result := VariantAsPyObject( Integer( Self.TabOrder ) )
    else if CompareText( key, 'TabStop' ) = 0 then Result := VariantAsPyObject( Self.TabStop )
    else if CompareText( key, 'HelpContext' ) = 0 then Result := VariantAsPyObject( Integer( Self.HelpContext ) )
    else Result := TControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function TWinControl_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( argSelf, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    // Check attribute
    Result := TWinControl_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TWinControl_WriteAttribute( Self : TWinControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'DockClientCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DoubleBuffered' ) = 0 then begin
      Self.DoubleBuffered := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Brush' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ControlCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ParentWindow' ) = 0 then begin
      Self.ParentWindow := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Showing' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'TabOrder' ) = 0 then begin
      Self.TabOrder := TTabOrder(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'TabStop' ) = 0 then begin
      Self.TabStop := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HelpContext' ) = 0 then begin
      Self.HelpContext := THelpContext(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else Result := TControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TWinControl_CreateParentedControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : TWinControl;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TWinControl.CreateParentedControl', [ 
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.CreateParentedControl( HWnd(_argParentWindow) );
    Result := GetPythonObject( rslt, 'Controls', 'TWinControl' );
  end;
end;

function TWinControl_Broadcast( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TWinControl_CanFocus( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.CanFocus;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TWinControl_ContainsControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : Boolean;
  _argControl : PPyObject;
  _objControl : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWinControl.ContainsControl', [ 
                  @_argControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objControl := GetObjectOf( _argControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.ContainsControl( _objControl );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TWinControl_ControlAtPos( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : TControl;
  _argPos : PPyObject;
  _argAllowDisabled : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oi:TWinControl.ControlAtPos', [ 
                  @_argPos,
                  @_argAllowDisabled       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.ControlAtPos( PyObjectAsPoint( _argPos ), Boolean(_argAllowDisabled) );
    Result := GetPythonObject( rslt, 'Controls', 'TControl' );
  end;
end;

function TWinControl_DefaultHandler( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TWinControl_DisableAlign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.DisableAlign;
    Result := ReturnNone;
  end;
end;

function TWinControl_DockClients( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : TControl;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TWinControl.DockClients', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.DockClients[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Controls', 'TControl' );
  end;
end;

function TWinControl_DockDrop( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argSource : PPyObject;
  _objSource : TDragDockObject;
  _argX : Integer;
  _argY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oii:TWinControl.DockDrop', [ 
                  @_argSource,
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TDragDockObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.DockDrop( _objSource, Integer(_argX), Integer(_argY) );
    Result := ReturnNone;
  end;
end;

function TWinControl_EnableAlign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.EnableAlign;
    Result := ReturnNone;
  end;
end;

function TWinControl_FindChildControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : TControl;
  _argControlName : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TWinControl.FindChildControl', [ 
                  @_argControlName       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.FindChildControl( string(_argControlName) );
    Result := GetPythonObject( rslt, 'Controls', 'TControl' );
  end;
end;

function TWinControl_FlipChildren( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argAllLevels : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TWinControl.FlipChildren', [ 
                  @_argAllLevels       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.FlipChildren( Boolean(_argAllLevels) );
    Result := ReturnNone;
  end;
end;

function TWinControl_Focused( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.Focused;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TWinControl_GetTabOrderList( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argList : PPyObject;
  _objList : TList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWinControl.GetTabOrderList', [ 
                  @_argList       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objList := GetObjectOf( _argList ) as TList;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.GetTabOrderList( _objList );
    Result := ReturnNone;
  end;
end;

function TWinControl_HandleAllocated( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.HandleAllocated;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TWinControl_HandleNeeded( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.HandleNeeded;
    Result := ReturnNone;
  end;
end;

function TWinControl_InsertControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argAControl : PPyObject;
  _objAControl : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWinControl.InsertControl', [ 
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.InsertControl( _objAControl );
    Result := ReturnNone;
  end;
end;

function TWinControl_Invalidate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.Invalidate;
    Result := ReturnNone;
  end;
end;

function TWinControl_MouseWheelHandler( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TWinControl_PaintTo( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argDC : Integer;
  _argX : Integer;
  _argY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TWinControl.PaintTo', [ 
                  @_argDC,
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.PaintTo( HDC(_argDC), Integer(_argX), Integer(_argY) );
    Result := ReturnNone;
  end;
end;

function TWinControl_RemoveControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argAControl : PPyObject;
  _objAControl : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TWinControl.RemoveControl', [ 
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.RemoveControl( _objAControl );
    Result := ReturnNone;
  end;
end;

function TWinControl_Realign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.Realign;
    Result := ReturnNone;
  end;
end;

function TWinControl_Repaint( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.Repaint;
    Result := ReturnNone;
  end;
end;

function TWinControl_ScaleBy( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argM : Integer;
  _argD : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TWinControl.ScaleBy', [ 
                  @_argM,
                  @_argD       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.ScaleBy( Integer(_argM), Integer(_argD) );
    Result := ReturnNone;
  end;
end;

function TWinControl_ScrollBy( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argDeltaX : Integer;
  _argDeltaY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TWinControl.ScrollBy', [ 
                  @_argDeltaX,
                  @_argDeltaY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.ScrollBy( Integer(_argDeltaX), Integer(_argDeltaY) );
    Result := ReturnNone;
  end;
end;

function TWinControl_SetBounds( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  _argALeft : Integer;
  _argATop : Integer;
  _argAWidth : Integer;
  _argAHeight : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiii:TWinControl.SetBounds', [ 
                  @_argALeft,
                  @_argATop,
                  @_argAWidth,
                  @_argAHeight       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.SetBounds( Integer(_argALeft), Integer(_argATop), Integer(_argAWidth), Integer(_argAHeight) );
    Result := ReturnNone;
  end;
end;

function TWinControl_SetFocus( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.SetFocus;
    Result := ReturnNone;
  end;
end;

function TWinControl_Update( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.Update;
    Result := ReturnNone;
  end;
end;

function TWinControl_UpdateControlState( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    realObj.UpdateControlState;
    Result := ReturnNone;
  end;
end;

function TWinControl_Controls( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TWinControl;
  rslt : TControl;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TWinControl.Controls', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TWinControl) then begin
      ErrorWrongExpectedType( Self, 'TWinControl' );
      Exit;
    end;
    realObj := TWinControl(obj);
    rslt := realObj.Controls[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Controls', 'TControl' );
  end;
end;

///////////// Functions for class TGraphicControl //////////////////

function TGraphicControl_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyGraphicControl;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TGraphicControl.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyGraphicControl.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TGraphicControl_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TGraphicControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphicControl) then begin
      ErrorWrongExpectedType( argSelf, 'TGraphicControl' );
      Exit;
    end;
    realObj := TGraphicControl(obj);
    // Check attribute
    Result := TGraphicControl_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TGraphicControl_ReadAttribute( Self : TGraphicControl; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTGraphicControl.MethodCount > 0 then 
      Result := Py_FindMethod( gTGraphicControl.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function TGraphicControl_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TGraphicControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphicControl) then begin
      ErrorWrongExpectedType( argSelf, 'TGraphicControl' );
      Exit;
    end;
    realObj := TGraphicControl(obj);
    // Check attribute
    Result := TGraphicControl_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TGraphicControl_WriteAttribute( Self : TGraphicControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TCustomControl //////////////////

function TCustomControl_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomControl;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCustomControl.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomControl.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomControl_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomControl;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TCustomControl.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomControl.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomControl_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomControl) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomControl' );
      Exit;
    end;
    realObj := TCustomControl(obj);
    // Check attribute
    Result := TCustomControl_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCustomControl_ReadAttribute( Self : TCustomControl; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCustomControl.MethodCount > 0 then 
      Result := Py_FindMethod( gTCustomControl.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TWinControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCustomControl_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomControl) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomControl' );
      Exit;
    end;
    realObj := TCustomControl(obj);
    // Check attribute
    Result := TCustomControl_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCustomControl_WriteAttribute( Self : TCustomControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TWinControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class THintWindow //////////////////

function THintWindow_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyHintWindow;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:THintWindow.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyHintWindow.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function THintWindow_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyHintWindow;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:THintWindow.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyHintWindow.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function THintWindow_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : THintWindow;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is THintWindow) then begin
      ErrorWrongExpectedType( argSelf, 'THintWindow' );
      Exit;
    end;
    realObj := THintWindow(obj);
    // Check attribute
    Result := THintWindow_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function THintWindow_ReadAttribute( Self : THintWindow; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTHintWindow.MethodCount > 0 then 
      Result := Py_FindMethod( gTHintWindow.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'BiDiMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.BiDiMode ) )
    else if CompareText( key, 'Caption' ) = 0 then Result := VariantAsPyObject( Self.Caption )
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Canvas' ) = 0 then Result := GetPythonObject( Self.Canvas, 'Controls', 'TCanvas' )
    else Result := TCustomControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function THintWindow_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : THintWindow;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is THintWindow) then begin
      ErrorWrongExpectedType( argSelf, 'THintWindow' );
      Exit;
    end;
    realObj := THintWindow(obj);
    // Check attribute
    Result := THintWindow_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function THintWindow_WriteAttribute( Self : THintWindow; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'BiDiMode' ) = 0 then begin
      Self.BiDiMode := TBiDiMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Caption' ) = 0 then begin
      Self.Caption := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Canvas' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TCustomControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function THintWindow_ActivateHint( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : THintWindow;
  _argRect : PPyObject;
  _argAHint : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Os:THintWindow.ActivateHint', [ 
                  @_argRect,
                  @_argAHint       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is THintWindow) then begin
      ErrorWrongExpectedType( Self, 'THintWindow' );
      Exit;
    end;
    realObj := THintWindow(obj);
    realObj.ActivateHint( PyObjectAsRect( _argRect ), string(_argAHint) );
    Result := ReturnNone;
  end;
end;

function THintWindow_ActivateHintData( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function THintWindow_CalcHintRect( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function THintWindow_IsHintMsg( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function THintWindow_ReleaseHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : THintWindow;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is THintWindow) then begin
      ErrorWrongExpectedType( Self, 'THintWindow' );
      Exit;
    end;
    realObj := THintWindow(obj);
    realObj.ReleaseHandle;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TDragImageList //////////////////

function TDragImageList_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDragImageList;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TDragImageList.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDragImageList.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDragImageList_CreateSize( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDragImageList;
  _argSelf : PPyObject;
  _argAWidth : Integer;
  _argAHeight : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oii:TDragImageList.CreateSize', [ @_argSelf,
                  @_argAWidth,
                  @_argAHeight       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDragImageList.CreateSize( Integer(_argAWidth), Integer(_argAHeight) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDragImageList_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( argSelf, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    // Check attribute
    Result := TDragImageList_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TDragImageList_ReadAttribute( Self : TDragImageList; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTDragImageList.MethodCount > 0 then 
      Result := Py_FindMethod( gTDragImageList.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'DragCursor' ) = 0 then Result := VariantAsPyObject( Integer( Self.DragCursor ) )
    else if CompareText( key, 'Dragging' ) = 0 then Result := VariantAsPyObject( Self.Dragging )
    else Result := TCustomImageList_ReadAttribute( Self, argSelf, key );
  end;
end;

function TDragImageList_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDragImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( argSelf, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    // Check attribute
    Result := TDragImageList_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TDragImageList_WriteAttribute( Self : TDragImageList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'DragCursor' ) = 0 then begin
      Self.DragCursor := TCursor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Dragging' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TCustomImageList_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TDragImageList_BeginDrag( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragImageList;
  rslt : Boolean;
  _argWindow : Integer;
  _argX : Integer;
  _argY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TDragImageList.BeginDrag', [ 
                  @_argWindow,
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( Self, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    rslt := realObj.BeginDrag( HWND(_argWindow), Integer(_argX), Integer(_argY) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TDragImageList_DragLock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragImageList;
  rslt : Boolean;
  _argWindow : Integer;
  _argXPos : Integer;
  _argYPos : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TDragImageList.DragLock', [ 
                  @_argWindow,
                  @_argXPos,
                  @_argYPos       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( Self, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    rslt := realObj.DragLock( HWND(_argWindow), Integer(_argXPos), Integer(_argYPos) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TDragImageList_DragMove( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragImageList;
  rslt : Boolean;
  _argX : Integer;
  _argY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TDragImageList.DragMove', [ 
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( Self, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    rslt := realObj.DragMove( Integer(_argX), Integer(_argY) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TDragImageList_DragUnlock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( Self, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    realObj.DragUnlock;
    Result := ReturnNone;
  end;
end;

function TDragImageList_EndDrag( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragImageList;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( Self, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    rslt := realObj.EndDrag;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TDragImageList_GetHotSpot( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragImageList;
  rslt : TPoint;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( Self, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    rslt := realObj.GetHotSpot;
    Result := CreatePoint( rslt ).GetSelf;
  end;
end;

function TDragImageList_HideDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( Self, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    realObj.HideDragImage;
    Result := ReturnNone;
  end;
end;

function TDragImageList_SetDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragImageList;
  rslt : Boolean;
  _argIndex : Integer;
  _argHotSpotX : Integer;
  _argHotSpotY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TDragImageList.SetDragImage', [ 
                  @_argIndex,
                  @_argHotSpotX,
                  @_argHotSpotY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( Self, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    rslt := realObj.SetDragImage( Integer(_argIndex), Integer(_argHotSpotX), Integer(_argHotSpotY) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TDragImageList_ShowDragImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDragImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDragImageList) then begin
      ErrorWrongExpectedType( Self, 'TDragImageList' );
      Exit;
    end;
    realObj := TDragImageList(obj);
    realObj.ShowDragImage;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TImageList //////////////////

function TImageList_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyImageList;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TImageList.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyImageList.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TImageList_CreateSize( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyImageList;
  _argSelf : PPyObject;
  _argAWidth : Integer;
  _argAHeight : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oii:TImageList.CreateSize', [ @_argSelf,
                  @_argAWidth,
                  @_argAHeight       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyImageList.CreateSize( Integer(_argAWidth), Integer(_argAHeight) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TImageList_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TImageList) then begin
      ErrorWrongExpectedType( argSelf, 'TImageList' );
      Exit;
    end;
    realObj := TImageList(obj);
    // Check attribute
    Result := TImageList_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TImageList_ReadAttribute( Self : TImageList; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTImageList.MethodCount > 0 then 
      Result := Py_FindMethod( gTImageList.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'BlendColor' ) = 0 then Result := VariantAsPyObject( Integer( Self.BlendColor ) )
    else if CompareText( key, 'BkColor' ) = 0 then Result := VariantAsPyObject( Integer( Self.BkColor ) )
    else if CompareText( key, 'AllocBy' ) = 0 then Result := VariantAsPyObject( Self.AllocBy )
    else if CompareText( key, 'DrawingStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.DrawingStyle ) )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'ImageType' ) = 0 then Result := VariantAsPyObject( Integer( Self.ImageType ) )
    else if CompareText( key, 'Masked' ) = 0 then Result := VariantAsPyObject( Self.Masked )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'ShareImages' ) = 0 then Result := VariantAsPyObject( Self.ShareImages )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else Result := TDragImageList_ReadAttribute( Self, argSelf, key );
  end;
end;

function TImageList_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TImageList;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TImageList) then begin
      ErrorWrongExpectedType( argSelf, 'TImageList' );
      Exit;
    end;
    realObj := TImageList(obj);
    // Check attribute
    Result := TImageList_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TImageList_WriteAttribute( Self : TImageList; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'BlendColor' ) = 0 then begin
      Self.BlendColor := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BkColor' ) = 0 then begin
      Self.BkColor := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'AllocBy' ) = 0 then begin
      Self.AllocBy := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DrawingStyle' ) = 0 then begin
      Self.DrawingStyle := TDrawingStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Height' ) = 0 then begin
      Self.Height := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ImageType' ) = 0 then begin
      Self.ImageType := TImageType(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Masked' ) = 0 then begin
      Self.Masked := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyImageList then
          with TPyImageList(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'ShareImages' ) = 0 then begin
      Self.ShareImages := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Width' ) = 0 then begin
      Self.Width := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TDragImageList_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TDockZone //////////////////

function TDockZone_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDockZone;
  _argSelf : PPyObject;
  _argTree : PPyObject;
  _objTree : TDockTree;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TDockZone.Create', [ @_argSelf,
                  @_argTree       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objTree := GetObjectOf( _argTree ) as TDockTree;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDockZone.Create( _objTree );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDockZone_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDockZone;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDockZone) then begin
      ErrorWrongExpectedType( argSelf, 'TDockZone' );
      Exit;
    end;
    realObj := TDockZone(obj);
    // Check attribute
    Result := TDockZone_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TDockZone_ReadAttribute( Self : TDockZone; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTDockZone.MethodCount > 0 then 
      Result := Py_FindMethod( gTDockZone.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'ChildCount' ) = 0 then Result := VariantAsPyObject( Self.ChildCount )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'Left' ) = 0 then Result := VariantAsPyObject( Self.Left )
    else if CompareText( key, 'LimitBegin' ) = 0 then Result := VariantAsPyObject( Self.LimitBegin )
    else if CompareText( key, 'LimitSize' ) = 0 then Result := VariantAsPyObject( Self.LimitSize )
    else if CompareText( key, 'Top' ) = 0 then Result := VariantAsPyObject( Self.Top )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TDockZone_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDockZone;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDockZone) then begin
      ErrorWrongExpectedType( argSelf, 'TDockZone' );
      Exit;
    end;
    realObj := TDockZone(obj);
    // Check attribute
    Result := TDockZone_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TDockZone_WriteAttribute( Self : TDockZone; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'ChildCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Height' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Left' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'LimitBegin' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'LimitSize' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Top' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Width' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TDockZone_ResetChildren( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDockZone;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDockZone) then begin
      ErrorWrongExpectedType( Self, 'TDockZone' );
      Exit;
    end;
    realObj := TDockZone(obj);
    realObj.ResetChildren;
    Result := ReturnNone;
  end;
end;

function TDockZone_Update( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDockZone;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDockZone) then begin
      ErrorWrongExpectedType( Self, 'TDockZone' );
      Exit;
    end;
    realObj := TDockZone(obj);
    realObj.Update;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TDockTree //////////////////

function TDockTree_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDockTree;
  _argSelf : PPyObject;
  _argDockSite : PPyObject;
  _objDockSite : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TDockTree.Create', [ @_argSelf,
                  @_argDockSite       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objDockSite := GetObjectOf( _argDockSite ) as TWinControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDockTree.Create( _objDockSite );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDockTree_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDockTree;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDockTree) then begin
      ErrorWrongExpectedType( argSelf, 'TDockTree' );
      Exit;
    end;
    realObj := TDockTree(obj);
    // Check attribute
    Result := TDockTree_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TDockTree_ReadAttribute( Self : TDockTree; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTDockTree.MethodCount > 0 then 
      Result := Py_FindMethod( gTDockTree.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TInterfacedObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TDockTree_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDockTree;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDockTree) then begin
      ErrorWrongExpectedType( argSelf, 'TDockTree' );
      Exit;
    end;
    realObj := TDockTree(obj);
    // Check attribute
    Result := TDockTree_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TDockTree_WriteAttribute( Self : TDockTree; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TInterfacedObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TDockTree_PaintSite( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDockTree;
  _argDC : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TDockTree.PaintSite', [ 
                  @_argDC       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDockTree) then begin
      ErrorWrongExpectedType( Self, 'TDockTree' );
      Exit;
    end;
    realObj := TDockTree(obj);
    realObj.PaintSite( HDC(_argDC) );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TMouse //////////////////

function TMouse_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMouse;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TMouse.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMouse.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMouse_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMouse;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMouse) then begin
      ErrorWrongExpectedType( argSelf, 'TMouse' );
      Exit;
    end;
    realObj := TMouse(obj);
    // Check attribute
    Result := TMouse_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMouse_ReadAttribute( Self : TMouse; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMouse.MethodCount > 0 then 
      Result := Py_FindMethod( gTMouse.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Capture' ) = 0 then Result := VariantAsPyObject( Self.Capture )
    else if CompareText( key, 'CursorPos' ) = 0 then Result := CreatePoint( Self.CursorPos ).GetSelf
    else if CompareText( key, 'DragImmediate' ) = 0 then Result := VariantAsPyObject( Self.DragImmediate )
    else if CompareText( key, 'DragThreshold' ) = 0 then Result := VariantAsPyObject( Self.DragThreshold )
    else if CompareText( key, 'MousePresent' ) = 0 then Result := VariantAsPyObject( Self.MousePresent )
    else if CompareText( key, 'RegWheelMessage' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'UINT' ); Result := nil; end
    else if CompareText( key, 'WheelPresent' ) = 0 then Result := VariantAsPyObject( Self.WheelPresent )
    else if CompareText( key, 'WheelScrollLines' ) = 0 then Result := VariantAsPyObject( Self.WheelScrollLines )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMouse_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMouse;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMouse) then begin
      ErrorWrongExpectedType( argSelf, 'TMouse' );
      Exit;
    end;
    realObj := TMouse(obj);
    // Check attribute
    Result := TMouse_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMouse_WriteAttribute( Self : TMouse; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Capture' ) = 0 then begin
      Self.Capture := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'CursorPos' ) = 0 then begin
      Self.CursorPos := PyObjectAsPoint( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragImmediate' ) = 0 then begin
      Self.DragImmediate := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragThreshold' ) = 0 then begin
      Self.DragThreshold := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MousePresent' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'RegWheelMessage' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'WheelPresent' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'WheelScrollLines' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TMouse_SettingChanged( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMouse;
  _argSetting : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TMouse.SettingChanged', [ 
                  @_argSetting       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMouse) then begin
      ErrorWrongExpectedType( Self, 'TMouse' );
      Exit;
    end;
    realObj := TMouse(obj);
    realObj.SettingChanged( Integer(_argSetting) );
    Result := ReturnNone;
  end;
end;

///////////// Initialization of the module ///////////

procedure TModule_Controls.Initialize;
begin
  // class TDragObject
  AddMethod( 'CreateDragObject', TDragObject_Create, '' );
  AddMethod( 'DragObject_GetAttr', TDragObject_GetAttr, '' );
  AddMethod( 'DragObject_SetAttr', TDragObject_SetAttr, '' );
  gTDragObject.AddMethod( 'Assign', TDragObject_Assign, '' );
  gTDragObject.AddMethod( 'GetName', TDragObject_GetName, '' );
  gTDragObject.AddMethod( 'HideDragImage', TDragObject_HideDragImage, '' );
  gTDragObject.AddMethod( 'Instance', TDragObject_Instance, '' );
  gTDragObject.AddMethod( 'ShowDragImage', TDragObject_ShowDragImage, '' );
  // class TBaseDragControlObject
  AddMethod( 'CreateBaseDragControlObject', TBaseDragControlObject_Create, '' );
  AddMethod( 'BaseDragControlObject_GetAttr', TBaseDragControlObject_GetAttr, '' );
  AddMethod( 'BaseDragControlObject_SetAttr', TBaseDragControlObject_SetAttr, '' );
  gTBaseDragControlObject.AddMethod( 'Create', TBaseDragControlObject_Create, '' );
  gTBaseDragControlObject.AddMethod( 'Assign', TBaseDragControlObject_Assign, '' );
  // class TDragControlObject
  AddMethod( 'CreateDragControlObject', TDragControlObject_Create, '' );
  AddMethod( 'DragControlObject_GetAttr', TDragControlObject_GetAttr, '' );
  AddMethod( 'DragControlObject_SetAttr', TDragControlObject_SetAttr, '' );
  gTDragControlObject.AddMethod( 'HideDragImage', TDragControlObject_HideDragImage, '' );
  gTDragControlObject.AddMethod( 'ShowDragImage', TDragControlObject_ShowDragImage, '' );
  // class TDragDockObject
  AddMethod( 'CreateDragDockObject', TDragDockObject_Create, '' );
  AddMethod( 'DragDockObject_GetAttr', TDragDockObject_GetAttr, '' );
  AddMethod( 'DragDockObject_SetAttr', TDragDockObject_SetAttr, '' );
  gTDragDockObject.AddMethod( 'Create', TDragDockObject_Create, '' );
  gTDragDockObject.AddMethod( 'Assign', TDragDockObject_Assign, '' );
  // class TControlCanvas
  AddMethod( 'CreateControlCanvas', TControlCanvas_Create, '' );
  AddMethod( 'ControlCanvas_GetAttr', TControlCanvas_GetAttr, '' );
  AddMethod( 'ControlCanvas_SetAttr', TControlCanvas_SetAttr, '' );
  gTControlCanvas.AddMethod( 'FreeHandle', TControlCanvas_FreeHandle, '' );
  gTControlCanvas.AddMethod( 'UpdateTextFlags', TControlCanvas_UpdateTextFlags, '' );
  // class TControlActionLink
  AddMethod( 'CreateControlActionLink', TControlActionLink_Create, '' );
  AddMethod( 'ControlActionLink_GetAttr', TControlActionLink_GetAttr, '' );
  AddMethod( 'ControlActionLink_SetAttr', TControlActionLink_SetAttr, '' );
  // class TSizeConstraints
  AddMethod( 'CreateSizeConstraints', TSizeConstraints_Create, '' );
  AddMethod( 'SizeConstraints_GetAttr', TSizeConstraints_GetAttr, '' );
  AddMethod( 'SizeConstraints_SetAttr', TSizeConstraints_SetAttr, '' );
  gTSizeConstraints.AddMethod( 'Create', TSizeConstraints_Create, '' );
  // class TControl
  AddMethod( 'CreateControl', TControl_Create, '' );
  AddMethod( 'Control_GetAttr', TControl_GetAttr, '' );
  AddMethod( 'Control_SetAttr', TControl_SetAttr, '' );
  gTControl.AddMethod( 'Create', TControl_Create, '' );
  gTControl.AddMethod( 'BeginDrag', TControl_BeginDrag, '' );
  gTControl.AddMethod( 'BringToFront', TControl_BringToFront, '' );
  gTControl.AddMethod( 'ClientToScreen', TControl_ClientToScreen, '' );
  gTControl.AddMethod( 'Dock', TControl_Dock, '' );
  gTControl.AddMethod( 'DefaultHandler', TControl_DefaultHandler, '' );
  gTControl.AddMethod( 'Dragging', TControl_Dragging, '' );
  gTControl.AddMethod( 'DragDrop', TControl_DragDrop, '' );
  gTControl.AddMethod( 'DrawTextBiDiModeFlags', TControl_DrawTextBiDiModeFlags, '' );
  gTControl.AddMethod( 'DrawTextBiDiModeFlagsReadingOnly', TControl_DrawTextBiDiModeFlagsReadingOnly, '' );
  gTControl.AddMethod( 'EndDrag', TControl_EndDrag, '' );
  gTControl.AddMethod( 'GetControlsAlignment', TControl_GetControlsAlignment, '' );
  gTControl.AddMethod( 'GetParentComponent', TControl_GetParentComponent, '' );
  gTControl.AddMethod( 'GetTextBuf', TControl_GetTextBuf, '' );
  gTControl.AddMethod( 'GetTextLen', TControl_GetTextLen, '' );
  gTControl.AddMethod( 'HasParent', TControl_HasParent, '' );
  gTControl.AddMethod( 'Hide', TControl_Hide, '' );
  gTControl.AddMethod( 'InitiateAction', TControl_InitiateAction, '' );
  gTControl.AddMethod( 'Invalidate', TControl_Invalidate, '' );
  gTControl.AddMethod( 'IsRightToLeft', TControl_IsRightToLeft, '' );
  gTControl.AddMethod( 'ManualDock', TControl_ManualDock, '' );
  gTControl.AddMethod( 'ManualFloat', TControl_ManualFloat, '' );
  gTControl.AddMethod( 'Perform', TControl_Perform, '' );
  gTControl.AddMethod( 'Refresh', TControl_Refresh, '' );
  gTControl.AddMethod( 'Repaint', TControl_Repaint, '' );
  gTControl.AddMethod( 'ReplaceDockedControl', TControl_ReplaceDockedControl, '' );
  gTControl.AddMethod( 'ScreenToClient', TControl_ScreenToClient, '' );
  gTControl.AddMethod( 'SendToBack', TControl_SendToBack, '' );
  gTControl.AddMethod( 'SetBounds', TControl_SetBounds, '' );
  gTControl.AddMethod( 'SetTextBuf', TControl_SetTextBuf, '' );
  gTControl.AddMethod( 'Show', TControl_Show, '' );
  gTControl.AddMethod( 'Update', TControl_Update, '' );
  gTControl.AddMethod( 'UseRightToLeftAlignment', TControl_UseRightToLeftAlignment, '' );
  gTControl.AddMethod( 'UseRightToLeftReading', TControl_UseRightToLeftReading, '' );
  gTControl.AddMethod( 'UseRightToLeftScrollBar', TControl_UseRightToLeftScrollBar, '' );
  // class TWinControlActionLink
  AddMethod( 'CreateWinControlActionLink', TWinControlActionLink_Create, '' );
  AddMethod( 'WinControlActionLink_GetAttr', TWinControlActionLink_GetAttr, '' );
  AddMethod( 'WinControlActionLink_SetAttr', TWinControlActionLink_SetAttr, '' );
  // class TWinControl
  AddMethod( 'CreateWinControl', TWinControl_Create, '' );
  AddMethod( 'CreateParentedWinControl', TWinControl_CreateParented, '' );
  AddMethod( 'WinControl_GetAttr', TWinControl_GetAttr, '' );
  AddMethod( 'WinControl_SetAttr', TWinControl_SetAttr, '' );
  gTWinControl.AddMethod( 'Create', TWinControl_Create, '' );
  gTWinControl.AddMethod( 'CreateParented', TWinControl_CreateParented, '' );
  gTWinControl.AddMethod( 'CreateParentedControl', TWinControl_CreateParentedControl, '' );
  gTWinControl.AddMethod( 'Broadcast', TWinControl_Broadcast, '' );
  gTWinControl.AddMethod( 'CanFocus', TWinControl_CanFocus, '' );
  gTWinControl.AddMethod( 'ContainsControl', TWinControl_ContainsControl, '' );
  gTWinControl.AddMethod( 'ControlAtPos', TWinControl_ControlAtPos, '' );
  gTWinControl.AddMethod( 'DefaultHandler', TWinControl_DefaultHandler, '' );
  gTWinControl.AddMethod( 'DisableAlign', TWinControl_DisableAlign, '' );
  gTWinControl.AddMethod( 'DockClients', TWinControl_DockClients, '' );
  gTWinControl.AddMethod( 'DockDrop', TWinControl_DockDrop, '' );
  gTWinControl.AddMethod( 'EnableAlign', TWinControl_EnableAlign, '' );
  gTWinControl.AddMethod( 'FindChildControl', TWinControl_FindChildControl, '' );
  gTWinControl.AddMethod( 'FlipChildren', TWinControl_FlipChildren, '' );
  gTWinControl.AddMethod( 'Focused', TWinControl_Focused, '' );
  gTWinControl.AddMethod( 'GetTabOrderList', TWinControl_GetTabOrderList, '' );
  gTWinControl.AddMethod( 'HandleAllocated', TWinControl_HandleAllocated, '' );
  gTWinControl.AddMethod( 'HandleNeeded', TWinControl_HandleNeeded, '' );
  gTWinControl.AddMethod( 'InsertControl', TWinControl_InsertControl, '' );
  gTWinControl.AddMethod( 'Invalidate', TWinControl_Invalidate, '' );
  gTWinControl.AddMethod( 'MouseWheelHandler', TWinControl_MouseWheelHandler, '' );
  gTWinControl.AddMethod( 'PaintTo', TWinControl_PaintTo, '' );
  gTWinControl.AddMethod( 'RemoveControl', TWinControl_RemoveControl, '' );
  gTWinControl.AddMethod( 'Realign', TWinControl_Realign, '' );
  gTWinControl.AddMethod( 'Repaint', TWinControl_Repaint, '' );
  gTWinControl.AddMethod( 'ScaleBy', TWinControl_ScaleBy, '' );
  gTWinControl.AddMethod( 'ScrollBy', TWinControl_ScrollBy, '' );
  gTWinControl.AddMethod( 'SetBounds', TWinControl_SetBounds, '' );
  gTWinControl.AddMethod( 'SetFocus', TWinControl_SetFocus, '' );
  gTWinControl.AddMethod( 'Update', TWinControl_Update, '' );
  gTWinControl.AddMethod( 'UpdateControlState', TWinControl_UpdateControlState, '' );
  gTWinControl.AddMethod( 'Controls', TWinControl_Controls, '' );
  // class TGraphicControl
  AddMethod( 'CreateGraphicControl', TGraphicControl_Create, '' );
  AddMethod( 'GraphicControl_GetAttr', TGraphicControl_GetAttr, '' );
  AddMethod( 'GraphicControl_SetAttr', TGraphicControl_SetAttr, '' );
  gTGraphicControl.AddMethod( 'Create', TGraphicControl_Create, '' );
  // class TCustomControl
  AddMethod( 'CreateCustomControl', TCustomControl_Create, '' );
  AddMethod( 'CreateParentedCustomControl', TCustomControl_CreateParented, '' );
  AddMethod( 'CustomControl_GetAttr', TCustomControl_GetAttr, '' );
  AddMethod( 'CustomControl_SetAttr', TCustomControl_SetAttr, '' );
  gTCustomControl.AddMethod( 'Create', TCustomControl_Create, '' );
  // class THintWindow
  AddMethod( 'CreateHintWindow', THintWindow_Create, '' );
  AddMethod( 'CreateParentedHintWindow', THintWindow_CreateParented, '' );
  AddMethod( 'HintWindow_GetAttr', THintWindow_GetAttr, '' );
  AddMethod( 'HintWindow_SetAttr', THintWindow_SetAttr, '' );
  gTHintWindow.AddMethod( 'Create', THintWindow_Create, '' );
  gTHintWindow.AddMethod( 'ActivateHint', THintWindow_ActivateHint, '' );
  gTHintWindow.AddMethod( 'ActivateHintData', THintWindow_ActivateHintData, '' );
  gTHintWindow.AddMethod( 'CalcHintRect', THintWindow_CalcHintRect, '' );
  gTHintWindow.AddMethod( 'IsHintMsg', THintWindow_IsHintMsg, '' );
  gTHintWindow.AddMethod( 'ReleaseHandle', THintWindow_ReleaseHandle, '' );
  // class TDragImageList
  AddMethod( 'CreateDragImageList', TDragImageList_Create, '' );
  AddMethod( 'CreateSizeDragImageList', TDragImageList_CreateSize, '' );
  AddMethod( 'DragImageList_GetAttr', TDragImageList_GetAttr, '' );
  AddMethod( 'DragImageList_SetAttr', TDragImageList_SetAttr, '' );
  gTDragImageList.AddMethod( 'BeginDrag', TDragImageList_BeginDrag, '' );
  gTDragImageList.AddMethod( 'DragLock', TDragImageList_DragLock, '' );
  gTDragImageList.AddMethod( 'DragMove', TDragImageList_DragMove, '' );
  gTDragImageList.AddMethod( 'DragUnlock', TDragImageList_DragUnlock, '' );
  gTDragImageList.AddMethod( 'EndDrag', TDragImageList_EndDrag, '' );
  gTDragImageList.AddMethod( 'GetHotSpot', TDragImageList_GetHotSpot, '' );
  gTDragImageList.AddMethod( 'HideDragImage', TDragImageList_HideDragImage, '' );
  gTDragImageList.AddMethod( 'SetDragImage', TDragImageList_SetDragImage, '' );
  gTDragImageList.AddMethod( 'ShowDragImage', TDragImageList_ShowDragImage, '' );
  // class TImageList
  AddMethod( 'CreateImageList', TImageList_Create, '' );
  AddMethod( 'CreateSizeImageList', TImageList_CreateSize, '' );
  AddMethod( 'ImageList_GetAttr', TImageList_GetAttr, '' );
  AddMethod( 'ImageList_SetAttr', TImageList_SetAttr, '' );
  // class TDockZone
  AddMethod( 'CreateDockZone', TDockZone_Create, '' );
  AddMethod( 'DockZone_GetAttr', TDockZone_GetAttr, '' );
  AddMethod( 'DockZone_SetAttr', TDockZone_SetAttr, '' );
  gTDockZone.AddMethod( 'Create', TDockZone_Create, '' );
  gTDockZone.AddMethod( 'ResetChildren', TDockZone_ResetChildren, '' );
  gTDockZone.AddMethod( 'Update', TDockZone_Update, '' );
  // class TDockTree
  AddMethod( 'CreateDockTree', TDockTree_Create, '' );
  AddMethod( 'DockTree_GetAttr', TDockTree_GetAttr, '' );
  AddMethod( 'DockTree_SetAttr', TDockTree_SetAttr, '' );
  gTDockTree.AddMethod( 'Create', TDockTree_Create, '' );
  gTDockTree.AddMethod( 'PaintSite', TDockTree_PaintSite, '' );
  // class TMouse
  AddMethod( 'CreateMouse', TMouse_Create, '' );
  AddMethod( 'Mouse_GetAttr', TMouse_GetAttr, '' );
  AddMethod( 'Mouse_SetAttr', TMouse_SetAttr, '' );
  gTMouse.AddMethod( 'Create', TMouse_Create, '' );
  gTMouse.AddMethod( 'SettingChanged', TMouse_SettingChanged, '' );
  inherited;
end;

end.
