////
//  This file was generated by VCL Generator
//  Copyright 1998 - Morgan Martinet
//  06/07/1999 07:58:54
//  it declares the content of the module _Graphics
////

unit Python_Graphics;

interface

uses
   Windows,
   Graphics,
   Classes,
   SysUtils,
   PythonEngine;

type
  TModule_Graphics = class( TPythonModule )
  public
    procedure Initialize; override;
  end;

  function TGraphicsObject_ReadAttribute( Self : TGraphicsObject; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TGraphicsObject_WriteAttribute( Self : TGraphicsObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TFont_ReadAttribute( Self : TFont; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TFont_WriteAttribute( Self : TFont; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TPen_ReadAttribute( Self : TPen; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TPen_WriteAttribute( Self : TPen; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TBrush_ReadAttribute( Self : TBrush; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TBrush_WriteAttribute( Self : TBrush; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCanvas_ReadAttribute( Self : TCanvas; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCanvas_WriteAttribute( Self : TCanvas; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TGraphic_ReadAttribute( Self : TGraphic; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TGraphic_WriteAttribute( Self : TGraphic; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TPicture_ReadAttribute( Self : TPicture; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TPicture_WriteAttribute( Self : TPicture; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TMetafileCanvas_ReadAttribute( Self : TMetafileCanvas; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMetafileCanvas_WriteAttribute( Self : TMetafileCanvas; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TSharedImage_ReadAttribute( Self : TSharedImage; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TSharedImage_WriteAttribute( Self : TSharedImage; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TMetafileImage_ReadAttribute( Self : TMetafileImage; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMetafileImage_WriteAttribute( Self : TMetafileImage; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TMetafile_ReadAttribute( Self : TMetafile; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMetafile_WriteAttribute( Self : TMetafile; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TBitmapImage_ReadAttribute( Self : TBitmapImage; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TBitmapImage_WriteAttribute( Self : TBitmapImage; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TBitmap_ReadAttribute( Self : TBitmap; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TBitmap_WriteAttribute( Self : TBitmap; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TIconImage_ReadAttribute( Self : TIconImage; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TIconImage_WriteAttribute( Self : TIconImage; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TIcon_ReadAttribute( Self : TIcon; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TIcon_WriteAttribute( Self : TIcon; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;

  procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 

implementation

uses
   Delphi_Classes,
   Python_Classes,
   Delphi_System,
   Delphi_Graphics,
   Python_System,
   Py_Misc,
   PyRecords,
   PyDelphiAssoc;

var
  IsInitialized : Boolean;
  gGraphics : TModule_Graphics;
  gEInvalidGraphic : TMethodsContainer;
  gEInvalidGraphicOperation : TMethodsContainer;
  gTGraphicsObject : TMethodsContainer;
  gTFont : TMethodsContainer;
  gTPen : TMethodsContainer;
  gTBrush : TMethodsContainer;
  gTCanvas : TMethodsContainer;
  gTGraphic : TMethodsContainer;
  gTPicture : TMethodsContainer;
  gTMetafileCanvas : TMethodsContainer;
  gTSharedImage : TMethodsContainer;
  gTMetafileImage : TMethodsContainer;
  gTMetafile : TMethodsContainer;
  gTBitmapImage : TMethodsContainer;
  gTBitmap : TMethodsContainer;
  gTIconImage : TMethodsContainer;
  gTIcon : TMethodsContainer;

procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 
begin
  if IsInitialized then
    Exit;
  IsInitialized := True;
  gGraphics := TModule_Graphics.Create( AOwner );
  with gGraphics do
    begin
      Engine := AEngine;
      ModuleName := '_Graphics';
    end;
  gEInvalidGraphic := TMethodsContainer.Create( AOwner );
  gEInvalidGraphicOperation := TMethodsContainer.Create( AOwner );
  gTGraphicsObject := TMethodsContainer.Create( AOwner );
  gTFont := TMethodsContainer.Create( AOwner );
  gTPen := TMethodsContainer.Create( AOwner );
  gTBrush := TMethodsContainer.Create( AOwner );
  gTCanvas := TMethodsContainer.Create( AOwner );
  gTGraphic := TMethodsContainer.Create( AOwner );
  gTPicture := TMethodsContainer.Create( AOwner );
  gTMetafileCanvas := TMethodsContainer.Create( AOwner );
  gTSharedImage := TMethodsContainer.Create( AOwner );
  gTMetafileImage := TMethodsContainer.Create( AOwner );
  gTMetafile := TMethodsContainer.Create( AOwner );
  gTBitmapImage := TMethodsContainer.Create( AOwner );
  gTBitmap := TMethodsContainer.Create( AOwner );
  gTIconImage := TMethodsContainer.Create( AOwner );
  gTIcon := TMethodsContainer.Create( AOwner );
end;

///////////// Functions for class TGraphicsObject //////////////////

function TGraphicsObject_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyGraphicsObject;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TGraphicsObject.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyGraphicsObject.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TGraphicsObject_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TGraphicsObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphicsObject) then begin
      ErrorWrongExpectedType( argSelf, 'TGraphicsObject' );
      Exit;
    end;
    realObj := TGraphicsObject(obj);
    // Check attribute
    Result := TGraphicsObject_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TGraphicsObject_ReadAttribute( Self : TGraphicsObject; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTGraphicsObject.MethodCount > 0 then 
      Result := Py_FindMethod( gTGraphicsObject.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OwnerCriticalSection' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'PRTLCriticalSection' ); Result := nil; end
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TGraphicsObject_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TGraphicsObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphicsObject) then begin
      ErrorWrongExpectedType( argSelf, 'TGraphicsObject' );
      Exit;
    end;
    realObj := TGraphicsObject(obj);
    // Check attribute
    Result := TGraphicsObject_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TGraphicsObject_WriteAttribute( Self : TGraphicsObject; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyGraphicsObject then
          with TPyGraphicsObject(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OwnerCriticalSection' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'PRTLCriticalSection' );
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TFont //////////////////

function TFont_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyFont;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TFont.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyFont.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TFont_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFont;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFont) then begin
      ErrorWrongExpectedType( argSelf, 'TFont' );
      Exit;
    end;
    realObj := TFont(obj);
    // Check attribute
    Result := TFont_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TFont_ReadAttribute( Self : TFont; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpStyle : TFontStyles;
begin
  with GetPythonEngine do begin
    if gTFont.MethodCount > 0 then 
      Result := Py_FindMethod( gTFont.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'FontAdapter' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'IChangeNotifier' ); Result := nil; end
    else if CompareText( key, 'Handle' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'HFont' ); Result := nil; end
    else if CompareText( key, 'PixelsPerInch' ) = 0 then Result := VariantAsPyObject( Self.PixelsPerInch )
    else if CompareText( key, 'Charset' ) = 0 then Result := VariantAsPyObject( Integer( Self.Charset ) )
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'Name' ) = 0 then Result := VariantAsPyObject( Self.Name )
    else if CompareText( key, 'Pitch' ) = 0 then Result := VariantAsPyObject( Integer( Self.Pitch ) )
    else if CompareText( key, 'Size' ) = 0 then Result := VariantAsPyObject( Self.Size )
    else if CompareText( key, 'Style' ) = 0 then begin
      tmpStyle := Self.Style;
      Result := SetToList( @tmpStyle, sizeof(tmpStyle) )
    end
    else Result := TGraphicsObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TFont_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFont;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFont) then begin
      ErrorWrongExpectedType( argSelf, 'TFont' );
      Exit;
    end;
    realObj := TFont(obj);
    // Check attribute
    Result := TFont_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TFont_WriteAttribute( Self : TFont; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpStyle : TFontStyles;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'FontAdapter' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'IChangeNotifier' );
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'HFont' );
    end else if CompareText( key, 'PixelsPerInch' ) = 0 then begin
      Self.PixelsPerInch := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Charset' ) = 0 then begin
      Self.Charset := TFontCharset(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Height' ) = 0 then begin
      Self.Height := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Name' ) = 0 then begin
      Self.Name := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Pitch' ) = 0 then begin
      Self.Pitch := TFontPitch(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Size' ) = 0 then begin
      Self.Size := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Style' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpStyle, sizeof(tmpStyle) );
        Self.Style := tmpStyle;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Style', 'TFontStyles' );
    end else Result := TGraphicsObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TFont_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TFont;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TFont.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TFont) then begin
      ErrorWrongExpectedType( Self, 'TFont' );
      Exit;
    end;
    realObj := TFont(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TPen //////////////////

function TPen_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyPen;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TPen.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyPen.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TPen_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPen;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPen) then begin
      ErrorWrongExpectedType( argSelf, 'TPen' );
      Exit;
    end;
    realObj := TPen(obj);
    // Check attribute
    Result := TPen_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TPen_ReadAttribute( Self : TPen; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTPen.MethodCount > 0 then 
      Result := Py_FindMethod( gTPen.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Handle' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'HPen' ); Result := nil; end
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Mode' ) = 0 then Result := VariantAsPyObject( Integer( Self.Mode ) )
    else if CompareText( key, 'Style' ) = 0 then Result := VariantAsPyObject( Integer( Self.Style ) )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else Result := TGraphicsObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TPen_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPen;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPen) then begin
      ErrorWrongExpectedType( argSelf, 'TPen' );
      Exit;
    end;
    realObj := TPen(obj);
    // Check attribute
    Result := TPen_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TPen_WriteAttribute( Self : TPen; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'HPen' );
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Mode' ) = 0 then begin
      Self.Mode := TPenMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Style' ) = 0 then begin
      Self.Style := TPenStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Width' ) = 0 then begin
      Self.Width := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TGraphicsObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TPen_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPen;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TPen.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPen) then begin
      ErrorWrongExpectedType( Self, 'TPen' );
      Exit;
    end;
    realObj := TPen(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TBrush //////////////////

function TBrush_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyBrush;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TBrush.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyBrush.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TBrush_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBrush;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBrush) then begin
      ErrorWrongExpectedType( argSelf, 'TBrush' );
      Exit;
    end;
    realObj := TBrush(obj);
    // Check attribute
    Result := TBrush_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TBrush_ReadAttribute( Self : TBrush; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTBrush.MethodCount > 0 then 
      Result := Py_FindMethod( gTBrush.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Bitmap' ) = 0 then Result := GetPythonObject( Self.Bitmap, 'Graphics', 'TBitmap' )
    else if CompareText( key, 'Handle' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'HBrush' ); Result := nil; end
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Style' ) = 0 then Result := VariantAsPyObject( Integer( Self.Style ) )
    else Result := TGraphicsObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TBrush_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBrush;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBrush) then begin
      ErrorWrongExpectedType( argSelf, 'TBrush' );
      Exit;
    end;
    realObj := TBrush(obj);
    // Check attribute
    Result := TBrush_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TBrush_WriteAttribute( Self : TBrush; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Bitmap' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBitmap then begin
        Self.Bitmap := TBitmap( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Bitmap', 'TBitmap' );
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'HBrush' );
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Style' ) = 0 then begin
      Self.Style := TBrushStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else Result := TGraphicsObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TBrush_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBrush;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBrush.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBrush) then begin
      ErrorWrongExpectedType( Self, 'TBrush' );
      Exit;
    end;
    realObj := TBrush(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TCanvas //////////////////

function TCanvas_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCanvas;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TCanvas.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCanvas.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCanvas_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( argSelf, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    // Check attribute
    Result := TCanvas_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCanvas_ReadAttribute( Self : TCanvas; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCanvas.MethodCount > 0 then 
      Result := Py_FindMethod( gTCanvas.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'ClipRect' ) = 0 then Result := CreateRect( Self.ClipRect ).GetSelf
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else if CompareText( key, 'LockCount' ) = 0 then Result := VariantAsPyObject( Self.LockCount )
    else if CompareText( key, 'CanvasOrientation' ) = 0 then Result := VariantAsPyObject( Integer( Self.CanvasOrientation ) )
    else if CompareText( key, 'PenPos' ) = 0 then Result := CreatePoint( Self.PenPos ).GetSelf
    else if CompareText( key, 'TextFlags' ) = 0 then Result := VariantAsPyObject( Self.TextFlags )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnChanging' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'Brush' ) = 0 then Result := GetPythonObject( Self.Brush, 'Graphics', 'TBrush' )
    else if CompareText( key, 'CopyMode' ) = 0 then Result := VariantAsPyObject( Self.CopyMode )
    else if CompareText( key, 'Font' ) = 0 then Result := GetPythonObject( Self.Font, 'Graphics', 'TFont' )
    else if CompareText( key, 'Pen' ) = 0 then Result := GetPythonObject( Self.Pen, 'Graphics', 'TPen' )
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCanvas_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( argSelf, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    // Check attribute
    Result := TCanvas_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCanvas_WriteAttribute( Self : TCanvas; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'ClipRect' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Handle' ) = 0 then begin
      Self.Handle := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'LockCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'CanvasOrientation' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'PenPos' ) = 0 then begin
      Self.PenPos := PyObjectAsPoint( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'TextFlags' ) = 0 then begin
      Self.TextFlags := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCanvas then
          with TPyCanvas(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnChanging' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChanging := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCanvas then
          with TPyCanvas(Self) do
            OnChanging := EventOnChanging;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'Brush' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBrush then begin
        Self.Brush := TBrush( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Brush', 'TBrush' );
    end else if CompareText( key, 'CopyMode' ) = 0 then begin
      Self.CopyMode := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Font' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TFont then begin
        Self.Font := TFont( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Font', 'TFont' );
    end else if CompareText( key, 'Pen' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TPen then begin
        Self.Pen := TPen( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Pen', 'TPen' );
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TCanvas_Arc( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX1 : Integer;
  _argY1 : Integer;
  _argX2 : Integer;
  _argY2 : Integer;
  _argX3 : Integer;
  _argY3 : Integer;
  _argX4 : Integer;
  _argY4 : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiiiiiii:TCanvas.Arc', [ 
                  @_argX1,
                  @_argY1,
                  @_argX2,
                  @_argY2,
                  @_argX3,
                  @_argY3,
                  @_argX4,
                  @_argY4       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.Arc( Integer(_argX1), Integer(_argY1), Integer(_argX2), Integer(_argY2), Integer(_argX3), Integer(_argY3), Integer(_argX4), Integer(_argY4) );
    Result := ReturnNone;
  end;
end;

function TCanvas_BrushCopy( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argDest : PPyObject;
  _argBitmap : PPyObject;
  _objBitmap : TBitmap;
  _argSource : PPyObject;
  _argColor : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OOOi:TCanvas.BrushCopy', [ 
                  @_argDest,
                  @_argBitmap,
                  @_argSource,
                  @_argColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objBitmap := GetObjectOf( _argBitmap ) as TBitmap;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.BrushCopy( PyObjectAsRect( _argDest ), _objBitmap, PyObjectAsRect( _argSource ), TColor(_argColor) );
    Result := ReturnNone;
  end;
end;

function TCanvas_Chord( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX1 : Integer;
  _argY1 : Integer;
  _argX2 : Integer;
  _argY2 : Integer;
  _argX3 : Integer;
  _argY3 : Integer;
  _argX4 : Integer;
  _argY4 : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiiiiiii:TCanvas.Chord', [ 
                  @_argX1,
                  @_argY1,
                  @_argX2,
                  @_argY2,
                  @_argX3,
                  @_argY3,
                  @_argX4,
                  @_argY4       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.Chord( Integer(_argX1), Integer(_argY1), Integer(_argX2), Integer(_argY2), Integer(_argX3), Integer(_argY3), Integer(_argX4), Integer(_argY4) );
    Result := ReturnNone;
  end;
end;

function TCanvas_CopyRect( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argDest : PPyObject;
  _argCanvas : PPyObject;
  _objCanvas : TCanvas;
  _argSource : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OOO:TCanvas.CopyRect', [ 
                  @_argDest,
                  @_argCanvas,
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objCanvas := GetObjectOf( _argCanvas ) as TCanvas;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.CopyRect( PyObjectAsRect( _argDest ), _objCanvas, PyObjectAsRect( _argSource ) );
    Result := ReturnNone;
  end;
end;

function TCanvas_Draw( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX : Integer;
  _argY : Integer;
  _argGraphic : PPyObject;
  _objGraphic : TGraphic;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiO:TCanvas.Draw', [ 
                  @_argX,
                  @_argY,
                  @_argGraphic       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objGraphic := GetObjectOf( _argGraphic ) as TGraphic;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.Draw( Integer(_argX), Integer(_argY), _objGraphic );
    Result := ReturnNone;
  end;
end;

function TCanvas_DrawFocusRect( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argRect : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCanvas.DrawFocusRect', [ 
                  @_argRect       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.DrawFocusRect( PyObjectAsRect( _argRect ) );
    Result := ReturnNone;
  end;
end;

function TCanvas_Ellipse( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX1 : Integer;
  _argY1 : Integer;
  _argX2 : Integer;
  _argY2 : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiii:TCanvas.Ellipse', [ 
                  @_argX1,
                  @_argY1,
                  @_argX2,
                  @_argY2       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.Ellipse( Integer(_argX1), Integer(_argY1), Integer(_argX2), Integer(_argY2) );
    Result := ReturnNone;
  end;
end;

function TCanvas_FillRect( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argRect : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCanvas.FillRect', [ 
                  @_argRect       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.FillRect( PyObjectAsRect( _argRect ) );
    Result := ReturnNone;
  end;
end;

function TCanvas_FloodFill( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX : Integer;
  _argY : Integer;
  _argColor : Integer;
  _argFillStyle : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiii:TCanvas.FloodFill', [ 
                  @_argX,
                  @_argY,
                  @_argColor,
                  @_argFillStyle       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.FloodFill( Integer(_argX), Integer(_argY), TColor(_argColor), TFillStyle(_argFillStyle) );
    Result := ReturnNone;
  end;
end;

function TCanvas_FrameRect( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argRect : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCanvas.FrameRect', [ 
                  @_argRect       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.FrameRect( PyObjectAsRect( _argRect ) );
    Result := ReturnNone;
  end;
end;

function TCanvas_LineTo( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX : Integer;
  _argY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TCanvas.LineTo', [ 
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.LineTo( Integer(_argX), Integer(_argY) );
    Result := ReturnNone;
  end;
end;

function TCanvas_Lock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.Lock;
    Result := ReturnNone;
  end;
end;

function TCanvas_MoveTo( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX : Integer;
  _argY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TCanvas.MoveTo', [ 
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.MoveTo( Integer(_argX), Integer(_argY) );
    Result := ReturnNone;
  end;
end;

function TCanvas_Pie( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX1 : Integer;
  _argY1 : Integer;
  _argX2 : Integer;
  _argY2 : Integer;
  _argX3 : Integer;
  _argY3 : Integer;
  _argX4 : Integer;
  _argY4 : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiiiiiii:TCanvas.Pie', [ 
                  @_argX1,
                  @_argY1,
                  @_argX2,
                  @_argY2,
                  @_argX3,
                  @_argY3,
                  @_argX4,
                  @_argY4       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.Pie( Integer(_argX1), Integer(_argY1), Integer(_argX2), Integer(_argY2), Integer(_argX3), Integer(_argY3), Integer(_argX4), Integer(_argY4) );
    Result := ReturnNone;
  end;
end;

function TCanvas_Polygon( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCanvas_Polyline( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCanvas_PolyBezier( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCanvas_PolyBezierTo( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCanvas_Rectangle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX1 : Integer;
  _argY1 : Integer;
  _argX2 : Integer;
  _argY2 : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiii:TCanvas.Rectangle', [ 
                  @_argX1,
                  @_argY1,
                  @_argX2,
                  @_argY2       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.Rectangle( Integer(_argX1), Integer(_argY1), Integer(_argX2), Integer(_argY2) );
    Result := ReturnNone;
  end;
end;

function TCanvas_Refresh( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.Refresh;
    Result := ReturnNone;
  end;
end;

function TCanvas_RoundRect( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX1 : Integer;
  _argY1 : Integer;
  _argX2 : Integer;
  _argY2 : Integer;
  _argX3 : Integer;
  _argY3 : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iiiiii:TCanvas.RoundRect', [ 
                  @_argX1,
                  @_argY1,
                  @_argX2,
                  @_argY2,
                  @_argX3,
                  @_argY3       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.RoundRect( Integer(_argX1), Integer(_argY1), Integer(_argX2), Integer(_argY2), Integer(_argX3), Integer(_argY3) );
    Result := ReturnNone;
  end;
end;

function TCanvas_StretchDraw( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argRect : PPyObject;
  _argGraphic : PPyObject;
  _objGraphic : TGraphic;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OO:TCanvas.StretchDraw', [ 
                  @_argRect,
                  @_argGraphic       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objGraphic := GetObjectOf( _argGraphic ) as TGraphic;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.StretchDraw( PyObjectAsRect( _argRect ), _objGraphic );
    Result := ReturnNone;
  end;
end;

function TCanvas_TextExtent( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  rslt : TSize;
  _argText : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TCanvas.TextExtent', [ 
                  @_argText       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    rslt := realObj.TextExtent( string(_argText) );
    Result := ReturnNone;
  end;
end;

function TCanvas_TextHeight( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  rslt : Integer;
  _argText : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TCanvas.TextHeight', [ 
                  @_argText       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    rslt := realObj.TextHeight( string(_argText) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCanvas_TextOut( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argX : Integer;
  _argY : Integer;
  _argText : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iis:TCanvas.TextOut', [ 
                  @_argX,
                  @_argY,
                  @_argText       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.TextOut( Integer(_argX), Integer(_argY), string(_argText) );
    Result := ReturnNone;
  end;
end;

function TCanvas_TextRect( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  _argRect : PPyObject;
  _argX : Integer;
  _argY : Integer;
  _argText : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oiis:TCanvas.TextRect', [ 
                  @_argRect,
                  @_argX,
                  @_argY,
                  @_argText       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.TextRect( PyObjectAsRect( _argRect ), Integer(_argX), Integer(_argY), string(_argText) );
    Result := ReturnNone;
  end;
end;

function TCanvas_TextWidth( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  rslt : Integer;
  _argText : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TCanvas.TextWidth', [ 
                  @_argText       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    rslt := realObj.TextWidth( string(_argText) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCanvas_TryLock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    rslt := realObj.TryLock;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCanvas_Unlock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    realObj.Unlock;
    Result := ReturnNone;
  end;
end;

function TCanvas_Pixels( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCanvas;
  rslt : TColor;
  _argX : Integer;
  _argY : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TCanvas.Pixels', [ 
                  @_argX,
                  @_argY       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCanvas) then begin
      ErrorWrongExpectedType( Self, 'TCanvas' );
      Exit;
    end;
    realObj := TCanvas(obj);
    rslt := realObj.Pixels[ Integer(_argX), Integer(_argY) ];
    Result := VariantAsPyObject( Integer( rslt ) );
  end;
end;

///////////// Functions for class TGraphic //////////////////

function TGraphic_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyGraphic;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TGraphic.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyGraphic.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TGraphic_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TGraphic;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphic) then begin
      ErrorWrongExpectedType( argSelf, 'TGraphic' );
      Exit;
    end;
    realObj := TGraphic(obj);
    // Check attribute
    Result := TGraphic_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TGraphic_ReadAttribute( Self : TGraphic; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTGraphic.MethodCount > 0 then 
      Result := Py_FindMethod( gTGraphic.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Empty' ) = 0 then Result := VariantAsPyObject( Self.Empty )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'Modified' ) = 0 then Result := VariantAsPyObject( Self.Modified )
    else if CompareText( key, 'Palette' ) = 0 then Result := VariantAsPyObject( Self.Palette )
    else if CompareText( key, 'PaletteModified' ) = 0 then Result := VariantAsPyObject( Self.PaletteModified )
    else if CompareText( key, 'Transparent' ) = 0 then Result := VariantAsPyObject( Self.Transparent )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnProgress' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TProgressEvent' ); Result := nil; end
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TGraphic_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TGraphic;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphic) then begin
      ErrorWrongExpectedType( argSelf, 'TGraphic' );
      Exit;
    end;
    realObj := TGraphic(obj);
    // Check attribute
    Result := TGraphic_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TGraphic_WriteAttribute( Self : TGraphic; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Empty' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Height' ) = 0 then begin
      Self.Height := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Modified' ) = 0 then begin
      Self.Modified := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Palette' ) = 0 then begin
      Self.Palette := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PaletteModified' ) = 0 then begin
      Self.PaletteModified := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Transparent' ) = 0 then begin
      Self.Transparent := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Width' ) = 0 then begin
      Self.Width := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyGraphic then
          with TPyGraphic(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnProgress' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnProgress := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyGraphic then
          with TPyGraphic(Self) do
            OnProgress := EventOnProgress;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TGraphic_LoadFromFile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TGraphic;
  _argFilename : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TGraphic.LoadFromFile', [ 
                  @_argFilename       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphic) then begin
      ErrorWrongExpectedType( Self, 'TGraphic' );
      Exit;
    end;
    realObj := TGraphic(obj);
    realObj.LoadFromFile( string(_argFilename) );
    Result := ReturnNone;
  end;
end;

function TGraphic_SaveToFile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TGraphic;
  _argFilename : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TGraphic.SaveToFile', [ 
                  @_argFilename       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphic) then begin
      ErrorWrongExpectedType( Self, 'TGraphic' );
      Exit;
    end;
    realObj := TGraphic(obj);
    realObj.SaveToFile( string(_argFilename) );
    Result := ReturnNone;
  end;
end;

function TGraphic_LoadFromStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TGraphic;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TGraphic.LoadFromStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphic) then begin
      ErrorWrongExpectedType( Self, 'TGraphic' );
      Exit;
    end;
    realObj := TGraphic(obj);
    realObj.LoadFromStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TGraphic_SaveToStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TGraphic;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TGraphic.SaveToStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphic) then begin
      ErrorWrongExpectedType( Self, 'TGraphic' );
      Exit;
    end;
    realObj := TGraphic(obj);
    realObj.SaveToStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TGraphic_LoadFromClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TGraphic;
  _argAFormat : Integer;
  _argAData : Integer;
  _argAPalette : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TGraphic.LoadFromClipboardFormat', [ 
                  @_argAFormat,
                  @_argAData,
                  @_argAPalette       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TGraphic) then begin
      ErrorWrongExpectedType( Self, 'TGraphic' );
      Exit;
    end;
    realObj := TGraphic(obj);
    realObj.LoadFromClipboardFormat( Word(_argAFormat), THandle(_argAData), HPALETTE(_argAPalette) );
    Result := ReturnNone;
  end;
end;

function TGraphic_SaveToClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TPicture //////////////////

function TPicture_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyPicture;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TPicture.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyPicture.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TPicture_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPicture;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPicture) then begin
      ErrorWrongExpectedType( argSelf, 'TPicture' );
      Exit;
    end;
    realObj := TPicture(obj);
    // Check attribute
    Result := TPicture_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TPicture_ReadAttribute( Self : TPicture; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTPicture.MethodCount > 0 then 
      Result := Py_FindMethod( gTPicture.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Bitmap' ) = 0 then Result := GetPythonObject( Self.Bitmap, 'Graphics', 'TBitmap' )
    else if CompareText( key, 'Graphic' ) = 0 then Result := GetPythonObject( Self.Graphic, 'Graphics', 'TGraphic' )
    else if CompareText( key, 'PictureAdapter' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'IChangeNotifier' ); Result := nil; end
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'Icon' ) = 0 then Result := GetPythonObject( Self.Icon, 'Graphics', 'TIcon' )
    else if CompareText( key, 'Metafile' ) = 0 then Result := GetPythonObject( Self.Metafile, 'Graphics', 'TMetafile' )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else if CompareText( key, 'OnChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnProgress' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TProgressEvent' ); Result := nil; end
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TPicture_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPicture;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPicture) then begin
      ErrorWrongExpectedType( argSelf, 'TPicture' );
      Exit;
    end;
    realObj := TPicture(obj);
    // Check attribute
    Result := TPicture_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TPicture_WriteAttribute( Self : TPicture; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Bitmap' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBitmap then begin
        Self.Bitmap := TBitmap( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Bitmap', 'TBitmap' );
    end else if CompareText( key, 'Graphic' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TGraphic then begin
        Self.Graphic := TGraphic( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Graphic', 'TGraphic' );
    end else if CompareText( key, 'PictureAdapter' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'IChangeNotifier' );
    end else if CompareText( key, 'Height' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Icon' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TIcon then begin
        Self.Icon := TIcon( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Icon', 'TIcon' );
    end else if CompareText( key, 'Metafile' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TMetafile then begin
        Self.Metafile := TMetafile( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Metafile', 'TMetafile' );
    end else if CompareText( key, 'Width' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'OnChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyPicture then
          with TPyPicture(Self) do
            OnChange := EventOnChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnProgress' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnProgress := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyPicture then
          with TPyPicture(Self) do
            OnProgress := EventOnProgress;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TPicture_LoadFromFile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPicture;
  _argFilename : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TPicture.LoadFromFile', [ 
                  @_argFilename       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPicture) then begin
      ErrorWrongExpectedType( Self, 'TPicture' );
      Exit;
    end;
    realObj := TPicture(obj);
    realObj.LoadFromFile( string(_argFilename) );
    Result := ReturnNone;
  end;
end;

function TPicture_SaveToFile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPicture;
  _argFilename : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TPicture.SaveToFile', [ 
                  @_argFilename       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPicture) then begin
      ErrorWrongExpectedType( Self, 'TPicture' );
      Exit;
    end;
    realObj := TPicture(obj);
    realObj.SaveToFile( string(_argFilename) );
    Result := ReturnNone;
  end;
end;

function TPicture_LoadFromClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPicture;
  _argAFormat : Integer;
  _argAData : Integer;
  _argAPalette : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TPicture.LoadFromClipboardFormat', [ 
                  @_argAFormat,
                  @_argAData,
                  @_argAPalette       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPicture) then begin
      ErrorWrongExpectedType( Self, 'TPicture' );
      Exit;
    end;
    realObj := TPicture(obj);
    realObj.LoadFromClipboardFormat( Word(_argAFormat), THandle(_argAData), HPALETTE(_argAPalette) );
    Result := ReturnNone;
  end;
end;

function TPicture_SaveToClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TPicture_SupportsClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPicture;
  rslt : Boolean;
  _argAFormat : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TPicture.SupportsClipboardFormat', [ 
                  @_argAFormat       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPicture) then begin
      ErrorWrongExpectedType( Self, 'TPicture' );
      Exit;
    end;
    realObj := TPicture(obj);
    rslt := realObj.SupportsClipboardFormat( Word(_argAFormat) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TPicture_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPicture;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TPicture.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPicture) then begin
      ErrorWrongExpectedType( Self, 'TPicture' );
      Exit;
    end;
    realObj := TPicture(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TPicture_RegisterFileFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TPicture_RegisterFileFormatRes( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TPicture_RegisterClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TPicture_UnregisterGraphicClass( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TMetafileCanvas //////////////////

function TMetafileCanvas_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMetafileCanvas;
  _argSelf : PPyObject;
  _argAMetafile : PPyObject;
  _objAMetafile : TMetafile;
  _argReferenceDevice : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TMetafileCanvas.Create', [ @_argSelf,
                  @_argAMetafile,
                  @_argReferenceDevice       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAMetafile := GetObjectOf( _argAMetafile ) as TMetafile;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMetafileCanvas.Create( _objAMetafile, HDC(_argReferenceDevice) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMetafileCanvas_CreateWithComment( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMetafileCanvas;
  _argSelf : PPyObject;
  _argAMetafile : PPyObject;
  _objAMetafile : TMetafile;
  _argReferenceDevice : Integer;
  _argCreatedBy : PChar;
  _argDescription : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOiss:TMetafileCanvas.CreateWithComment', [ @_argSelf,
                  @_argAMetafile,
                  @_argReferenceDevice,
                  @_argCreatedBy,
                  @_argDescription       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAMetafile := GetObjectOf( _argAMetafile ) as TMetafile;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMetafileCanvas.CreateWithComment( _objAMetafile, HDC(_argReferenceDevice), String(_argCreatedBy), String(_argDescription) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMetafileCanvas_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMetafileCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafileCanvas) then begin
      ErrorWrongExpectedType( argSelf, 'TMetafileCanvas' );
      Exit;
    end;
    realObj := TMetafileCanvas(obj);
    // Check attribute
    Result := TMetafileCanvas_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMetafileCanvas_ReadAttribute( Self : TMetafileCanvas; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMetafileCanvas.MethodCount > 0 then 
      Result := Py_FindMethod( gTMetafileCanvas.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TCanvas_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMetafileCanvas_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMetafileCanvas;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafileCanvas) then begin
      ErrorWrongExpectedType( argSelf, 'TMetafileCanvas' );
      Exit;
    end;
    realObj := TMetafileCanvas(obj);
    // Check attribute
    Result := TMetafileCanvas_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMetafileCanvas_WriteAttribute( Self : TMetafileCanvas; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TCanvas_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TSharedImage //////////////////

function TSharedImage_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPySharedImage;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TSharedImage.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPySharedImage.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TSharedImage_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TSharedImage;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TSharedImage) then begin
      ErrorWrongExpectedType( argSelf, 'TSharedImage' );
      Exit;
    end;
    realObj := TSharedImage(obj);
    // Check attribute
    Result := TSharedImage_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TSharedImage_ReadAttribute( Self : TSharedImage; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTSharedImage.MethodCount > 0 then 
      Result := Py_FindMethod( gTSharedImage.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TSharedImage_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TSharedImage;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TSharedImage) then begin
      ErrorWrongExpectedType( argSelf, 'TSharedImage' );
      Exit;
    end;
    realObj := TSharedImage(obj);
    // Check attribute
    Result := TSharedImage_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TSharedImage_WriteAttribute( Self : TSharedImage; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TMetafileImage //////////////////

function TMetafileImage_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMetafileImage;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TMetafileImage.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMetafileImage.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMetafileImage_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMetafileImage;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafileImage) then begin
      ErrorWrongExpectedType( argSelf, 'TMetafileImage' );
      Exit;
    end;
    realObj := TMetafileImage(obj);
    // Check attribute
    Result := TMetafileImage_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMetafileImage_ReadAttribute( Self : TMetafileImage; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMetafileImage.MethodCount > 0 then 
      Result := Py_FindMethod( gTMetafileImage.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TSharedImage_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMetafileImage_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMetafileImage;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafileImage) then begin
      ErrorWrongExpectedType( argSelf, 'TMetafileImage' );
      Exit;
    end;
    realObj := TMetafileImage(obj);
    // Check attribute
    Result := TMetafileImage_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMetafileImage_WriteAttribute( Self : TMetafileImage; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TSharedImage_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TMetafile //////////////////

function TMetafile_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMetafile;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TMetafile.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMetafile.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMetafile_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMetafile;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafile) then begin
      ErrorWrongExpectedType( argSelf, 'TMetafile' );
      Exit;
    end;
    realObj := TMetafile(obj);
    // Check attribute
    Result := TMetafile_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMetafile_ReadAttribute( Self : TMetafile; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMetafile.MethodCount > 0 then 
      Result := Py_FindMethod( gTMetafile.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'CreatedBy' ) = 0 then Result := VariantAsPyObject( Self.CreatedBy )
    else if CompareText( key, 'Description' ) = 0 then Result := VariantAsPyObject( Self.Description )
    else if CompareText( key, 'Enhanced' ) = 0 then Result := VariantAsPyObject( Self.Enhanced )
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else if CompareText( key, 'MMWidth' ) = 0 then Result := VariantAsPyObject( Self.MMWidth )
    else if CompareText( key, 'MMHeight' ) = 0 then Result := VariantAsPyObject( Self.MMHeight )
    else if CompareText( key, 'Inch' ) = 0 then Result := VariantAsPyObject( Self.Inch )
    else Result := TGraphic_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMetafile_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMetafile;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafile) then begin
      ErrorWrongExpectedType( argSelf, 'TMetafile' );
      Exit;
    end;
    realObj := TMetafile(obj);
    // Check attribute
    Result := TMetafile_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMetafile_WriteAttribute( Self : TMetafile; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'CreatedBy' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Description' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Enhanced' ) = 0 then begin
      Self.Enhanced := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Handle' ) = 0 then begin
      Self.Handle := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MMWidth' ) = 0 then begin
      Self.MMWidth := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MMHeight' ) = 0 then begin
      Self.MMHeight := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Inch' ) = 0 then begin
      Self.Inch := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TGraphic_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TMetafile_Clear( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMetafile;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafile) then begin
      ErrorWrongExpectedType( Self, 'TMetafile' );
      Exit;
    end;
    realObj := TMetafile(obj);
    realObj.Clear;
    Result := ReturnNone;
  end;
end;

function TMetafile_LoadFromStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMetafile;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMetafile.LoadFromStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafile) then begin
      ErrorWrongExpectedType( Self, 'TMetafile' );
      Exit;
    end;
    realObj := TMetafile(obj);
    realObj.LoadFromStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TMetafile_SaveToFile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMetafile;
  _argFilename : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TMetafile.SaveToFile', [ 
                  @_argFilename       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafile) then begin
      ErrorWrongExpectedType( Self, 'TMetafile' );
      Exit;
    end;
    realObj := TMetafile(obj);
    realObj.SaveToFile( String(_argFilename) );
    Result := ReturnNone;
  end;
end;

function TMetafile_SaveToStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMetafile;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMetafile.SaveToStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafile) then begin
      ErrorWrongExpectedType( Self, 'TMetafile' );
      Exit;
    end;
    realObj := TMetafile(obj);
    realObj.SaveToStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TMetafile_LoadFromClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMetafile;
  _argAFormat : Integer;
  _argAData : Integer;
  _argAPalette : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TMetafile.LoadFromClipboardFormat', [ 
                  @_argAFormat,
                  @_argAData,
                  @_argAPalette       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafile) then begin
      ErrorWrongExpectedType( Self, 'TMetafile' );
      Exit;
    end;
    realObj := TMetafile(obj);
    realObj.LoadFromClipboardFormat( Word(_argAFormat), THandle(_argAData), HPALETTE(_argAPalette) );
    Result := ReturnNone;
  end;
end;

function TMetafile_SaveToClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TMetafile_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMetafile;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TMetafile.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafile) then begin
      ErrorWrongExpectedType( Self, 'TMetafile' );
      Exit;
    end;
    realObj := TMetafile(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TMetafile_ReleaseHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TMetafile;
  rslt : HENHMETAFILE;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TMetafile) then begin
      ErrorWrongExpectedType( Self, 'TMetafile' );
      Exit;
    end;
    realObj := TMetafile(obj);
    rslt := realObj.ReleaseHandle;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TBitmapImage //////////////////

function TBitmapImage_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyBitmapImage;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TBitmapImage.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyBitmapImage.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TBitmapImage_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBitmapImage;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmapImage) then begin
      ErrorWrongExpectedType( argSelf, 'TBitmapImage' );
      Exit;
    end;
    realObj := TBitmapImage(obj);
    // Check attribute
    Result := TBitmapImage_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TBitmapImage_ReadAttribute( Self : TBitmapImage; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTBitmapImage.MethodCount > 0 then 
      Result := Py_FindMethod( gTBitmapImage.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TSharedImage_ReadAttribute( Self, argSelf, key );
  end;
end;

function TBitmapImage_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBitmapImage;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmapImage) then begin
      ErrorWrongExpectedType( argSelf, 'TBitmapImage' );
      Exit;
    end;
    realObj := TBitmapImage(obj);
    // Check attribute
    Result := TBitmapImage_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TBitmapImage_WriteAttribute( Self : TBitmapImage; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TSharedImage_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TBitmap //////////////////

function TBitmap_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyBitmap;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TBitmap.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyBitmap.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TBitmap_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBitmap;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( argSelf, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    // Check attribute
    Result := TBitmap_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TBitmap_ReadAttribute( Self : TBitmap; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTBitmap.MethodCount > 0 then 
      Result := Py_FindMethod( gTBitmap.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Canvas' ) = 0 then Result := GetPythonObject( Self.Canvas, 'Graphics', 'TCanvas' )
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else if CompareText( key, 'HandleType' ) = 0 then Result := VariantAsPyObject( Integer( Self.HandleType ) )
    else if CompareText( key, 'IgnorePalette' ) = 0 then Result := VariantAsPyObject( Self.IgnorePalette )
    else if CompareText( key, 'MaskHandle' ) = 0 then Result := VariantAsPyObject( Self.MaskHandle )
    else if CompareText( key, 'Monochrome' ) = 0 then Result := VariantAsPyObject( Self.Monochrome )
    else if CompareText( key, 'PixelFormat' ) = 0 then Result := VariantAsPyObject( Integer( Self.PixelFormat ) )
    else if CompareText( key, 'TransparentColor' ) = 0 then Result := VariantAsPyObject( Integer( Self.TransparentColor ) )
    else if CompareText( key, 'TransparentMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.TransparentMode ) )
    else Result := TGraphic_ReadAttribute( Self, argSelf, key );
  end;
end;

function TBitmap_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TBitmap;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( argSelf, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    // Check attribute
    Result := TBitmap_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TBitmap_WriteAttribute( Self : TBitmap; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Canvas' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Handle' ) = 0 then begin
      Self.Handle := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HandleType' ) = 0 then begin
      Self.HandleType := TBitmapHandleType(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'IgnorePalette' ) = 0 then begin
      Self.IgnorePalette := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MaskHandle' ) = 0 then begin
      Self.MaskHandle := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Monochrome' ) = 0 then begin
      Self.Monochrome := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PixelFormat' ) = 0 then begin
      Self.PixelFormat := TPixelFormat(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'TransparentColor' ) = 0 then begin
      Self.TransparentColor := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'TransparentMode' ) = 0 then begin
      Self.TransparentMode := TTransparentMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else Result := TGraphic_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TBitmap_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBitmap.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TBitmap_Dormant( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    realObj.Dormant;
    Result := ReturnNone;
  end;
end;

function TBitmap_FreeImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    realObj.FreeImage;
    Result := ReturnNone;
  end;
end;

function TBitmap_LoadFromClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  _argAFormat : Integer;
  _argAData : Integer;
  _argAPalette : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TBitmap.LoadFromClipboardFormat', [ 
                  @_argAFormat,
                  @_argAData,
                  @_argAPalette       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    realObj.LoadFromClipboardFormat( Word(_argAFormat), THandle(_argAData), HPALETTE(_argAPalette) );
    Result := ReturnNone;
  end;
end;

function TBitmap_LoadFromStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBitmap.LoadFromStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    realObj.LoadFromStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TBitmap_LoadFromResourceName( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  _argInstance : Integer;
  _argResName : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'is:TBitmap.LoadFromResourceName', [ 
                  @_argInstance,
                  @_argResName       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    realObj.LoadFromResourceName( THandle(_argInstance), String(_argResName) );
    Result := ReturnNone;
  end;
end;

function TBitmap_LoadFromResourceID( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  _argInstance : Integer;
  _argResID : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TBitmap.LoadFromResourceID', [ 
                  @_argInstance,
                  @_argResID       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    realObj.LoadFromResourceID( THandle(_argInstance), Integer(_argResID) );
    Result := ReturnNone;
  end;
end;

function TBitmap_Mask( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  _argTransparentColor : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TBitmap.Mask', [ 
                  @_argTransparentColor       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    realObj.Mask( TColor(_argTransparentColor) );
    Result := ReturnNone;
  end;
end;

function TBitmap_ReleaseHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  rslt : HBITMAP;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    rslt := realObj.ReleaseHandle;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TBitmap_ReleaseMaskHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  rslt : HBITMAP;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    rslt := realObj.ReleaseMaskHandle;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TBitmap_ReleasePalette( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  rslt : HPALETTE;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    rslt := realObj.ReleasePalette;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TBitmap_SaveToClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TBitmap_SaveToStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TBitmap.SaveToStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    realObj.SaveToStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TBitmap_ScanLine( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TBitmap;
  rslt : Pointer;
  _argRow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TBitmap.ScanLine', [ 
                  @_argRow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TBitmap) then begin
      ErrorWrongExpectedType( Self, 'TBitmap' );
      Exit;
    end;
    realObj := TBitmap(obj);
    rslt := realObj.ScanLine[ Integer(_argRow) ];
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TIconImage //////////////////

function TIconImage_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyIconImage;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TIconImage.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyIconImage.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TIconImage_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TIconImage;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TIconImage) then begin
      ErrorWrongExpectedType( argSelf, 'TIconImage' );
      Exit;
    end;
    realObj := TIconImage(obj);
    // Check attribute
    Result := TIconImage_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TIconImage_ReadAttribute( Self : TIconImage; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTIconImage.MethodCount > 0 then 
      Result := Py_FindMethod( gTIconImage.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TSharedImage_ReadAttribute( Self, argSelf, key );
  end;
end;

function TIconImage_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TIconImage;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TIconImage) then begin
      ErrorWrongExpectedType( argSelf, 'TIconImage' );
      Exit;
    end;
    realObj := TIconImage(obj);
    // Check attribute
    Result := TIconImage_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TIconImage_WriteAttribute( Self : TIconImage; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TSharedImage_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TIcon //////////////////

function TIcon_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyIcon;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TIcon.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyIcon.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TIcon_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TIcon;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TIcon) then begin
      ErrorWrongExpectedType( argSelf, 'TIcon' );
      Exit;
    end;
    realObj := TIcon(obj);
    // Check attribute
    Result := TIcon_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TIcon_ReadAttribute( Self : TIcon; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTIcon.MethodCount > 0 then 
      Result := Py_FindMethod( gTIcon.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else Result := TGraphic_ReadAttribute( Self, argSelf, key );
  end;
end;

function TIcon_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TIcon;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TIcon) then begin
      ErrorWrongExpectedType( argSelf, 'TIcon' );
      Exit;
    end;
    realObj := TIcon(obj);
    // Check attribute
    Result := TIcon_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TIcon_WriteAttribute( Self : TIcon; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Handle' ) = 0 then begin
      Self.Handle := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TGraphic_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TIcon_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TIcon;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TIcon.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TIcon) then begin
      ErrorWrongExpectedType( Self, 'TIcon' );
      Exit;
    end;
    realObj := TIcon(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TIcon_LoadFromClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TIcon;
  _argAFormat : Integer;
  _argAData : Integer;
  _argAPalette : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'iii:TIcon.LoadFromClipboardFormat', [ 
                  @_argAFormat,
                  @_argAData,
                  @_argAPalette       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TIcon) then begin
      ErrorWrongExpectedType( Self, 'TIcon' );
      Exit;
    end;
    realObj := TIcon(obj);
    realObj.LoadFromClipboardFormat( Word(_argAFormat), THandle(_argAData), HPALETTE(_argAPalette) );
    Result := ReturnNone;
  end;
end;

function TIcon_LoadFromStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TIcon;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TIcon.LoadFromStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TIcon) then begin
      ErrorWrongExpectedType( Self, 'TIcon' );
      Exit;
    end;
    realObj := TIcon(obj);
    realObj.LoadFromStream( _objStream );
    Result := ReturnNone;
  end;
end;

function TIcon_ReleaseHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TIcon;
  rslt : HICON;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TIcon) then begin
      ErrorWrongExpectedType( Self, 'TIcon' );
      Exit;
    end;
    realObj := TIcon(obj);
    rslt := realObj.ReleaseHandle;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TIcon_SaveToClipboardFormat( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TIcon_SaveToStream( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TIcon;
  _argStream : PPyObject;
  _objStream : TStream;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TIcon.SaveToStream', [ 
                  @_argStream       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objStream := GetObjectOf( _argStream ) as TStream;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TIcon) then begin
      ErrorWrongExpectedType( Self, 'TIcon' );
      Exit;
    end;
    realObj := TIcon(obj);
    realObj.SaveToStream( _objStream );
    Result := ReturnNone;
  end;
end;

///////////// Initialization of the module ///////////

procedure TModule_Graphics.Initialize;
begin
  // class TGraphicsObject
  AddMethod( 'CreateGraphicsObject', TGraphicsObject_Create, '' );
  AddMethod( 'GraphicsObject_GetAttr', TGraphicsObject_GetAttr, '' );
  AddMethod( 'GraphicsObject_SetAttr', TGraphicsObject_SetAttr, '' );
  // class TFont
  AddMethod( 'CreateFont', TFont_Create, '' );
  AddMethod( 'Font_GetAttr', TFont_GetAttr, '' );
  AddMethod( 'Font_SetAttr', TFont_SetAttr, '' );
  gTFont.AddMethod( 'Create', TFont_Create, '' );
  gTFont.AddMethod( 'Assign', TFont_Assign, '' );
  // class TPen
  AddMethod( 'CreatePen', TPen_Create, '' );
  AddMethod( 'Pen_GetAttr', TPen_GetAttr, '' );
  AddMethod( 'Pen_SetAttr', TPen_SetAttr, '' );
  gTPen.AddMethod( 'Create', TPen_Create, '' );
  gTPen.AddMethod( 'Assign', TPen_Assign, '' );
  // class TBrush
  AddMethod( 'CreateBrush', TBrush_Create, '' );
  AddMethod( 'Brush_GetAttr', TBrush_GetAttr, '' );
  AddMethod( 'Brush_SetAttr', TBrush_SetAttr, '' );
  gTBrush.AddMethod( 'Create', TBrush_Create, '' );
  gTBrush.AddMethod( 'Assign', TBrush_Assign, '' );
  // class TCanvas
  AddMethod( 'CreateCanvas', TCanvas_Create, '' );
  AddMethod( 'Canvas_GetAttr', TCanvas_GetAttr, '' );
  AddMethod( 'Canvas_SetAttr', TCanvas_SetAttr, '' );
  gTCanvas.AddMethod( 'Create', TCanvas_Create, '' );
  gTCanvas.AddMethod( 'Arc', TCanvas_Arc, '' );
  gTCanvas.AddMethod( 'BrushCopy', TCanvas_BrushCopy, '' );
  gTCanvas.AddMethod( 'Chord', TCanvas_Chord, '' );
  gTCanvas.AddMethod( 'CopyRect', TCanvas_CopyRect, '' );
  gTCanvas.AddMethod( 'Draw', TCanvas_Draw, '' );
  gTCanvas.AddMethod( 'DrawFocusRect', TCanvas_DrawFocusRect, '' );
  gTCanvas.AddMethod( 'Ellipse', TCanvas_Ellipse, '' );
  gTCanvas.AddMethod( 'FillRect', TCanvas_FillRect, '' );
  gTCanvas.AddMethod( 'FloodFill', TCanvas_FloodFill, '' );
  gTCanvas.AddMethod( 'FrameRect', TCanvas_FrameRect, '' );
  gTCanvas.AddMethod( 'LineTo', TCanvas_LineTo, '' );
  gTCanvas.AddMethod( 'Lock', TCanvas_Lock, '' );
  gTCanvas.AddMethod( 'MoveTo', TCanvas_MoveTo, '' );
  gTCanvas.AddMethod( 'Pie', TCanvas_Pie, '' );
  gTCanvas.AddMethod( 'Polygon', TCanvas_Polygon, '' );
  gTCanvas.AddMethod( 'Polyline', TCanvas_Polyline, '' );
  gTCanvas.AddMethod( 'PolyBezier', TCanvas_PolyBezier, '' );
  gTCanvas.AddMethod( 'PolyBezierTo', TCanvas_PolyBezierTo, '' );
  gTCanvas.AddMethod( 'Rectangle', TCanvas_Rectangle, '' );
  gTCanvas.AddMethod( 'Refresh', TCanvas_Refresh, '' );
  gTCanvas.AddMethod( 'RoundRect', TCanvas_RoundRect, '' );
  gTCanvas.AddMethod( 'StretchDraw', TCanvas_StretchDraw, '' );
  gTCanvas.AddMethod( 'TextExtent', TCanvas_TextExtent, '' );
  gTCanvas.AddMethod( 'TextHeight', TCanvas_TextHeight, '' );
  gTCanvas.AddMethod( 'TextOut', TCanvas_TextOut, '' );
  gTCanvas.AddMethod( 'TextRect', TCanvas_TextRect, '' );
  gTCanvas.AddMethod( 'TextWidth', TCanvas_TextWidth, '' );
  gTCanvas.AddMethod( 'TryLock', TCanvas_TryLock, '' );
  gTCanvas.AddMethod( 'Unlock', TCanvas_Unlock, '' );
  gTCanvas.AddMethod( 'Pixels', TCanvas_Pixels, '' );
  // class TGraphic
  AddMethod( 'CreateGraphic', TGraphic_Create, '' );
  AddMethod( 'Graphic_GetAttr', TGraphic_GetAttr, '' );
  AddMethod( 'Graphic_SetAttr', TGraphic_SetAttr, '' );
  gTGraphic.AddMethod( 'LoadFromFile', TGraphic_LoadFromFile, '' );
  gTGraphic.AddMethod( 'SaveToFile', TGraphic_SaveToFile, '' );
  gTGraphic.AddMethod( 'LoadFromStream', TGraphic_LoadFromStream, '' );
  gTGraphic.AddMethod( 'SaveToStream', TGraphic_SaveToStream, '' );
  gTGraphic.AddMethod( 'LoadFromClipboardFormat', TGraphic_LoadFromClipboardFormat, '' );
  gTGraphic.AddMethod( 'SaveToClipboardFormat', TGraphic_SaveToClipboardFormat, '' );
  // class TPicture
  AddMethod( 'CreatePicture', TPicture_Create, '' );
  AddMethod( 'Picture_GetAttr', TPicture_GetAttr, '' );
  AddMethod( 'Picture_SetAttr', TPicture_SetAttr, '' );
  gTPicture.AddMethod( 'Create', TPicture_Create, '' );
  gTPicture.AddMethod( 'LoadFromFile', TPicture_LoadFromFile, '' );
  gTPicture.AddMethod( 'SaveToFile', TPicture_SaveToFile, '' );
  gTPicture.AddMethod( 'LoadFromClipboardFormat', TPicture_LoadFromClipboardFormat, '' );
  gTPicture.AddMethod( 'SaveToClipboardFormat', TPicture_SaveToClipboardFormat, '' );
  gTPicture.AddMethod( 'SupportsClipboardFormat', TPicture_SupportsClipboardFormat, '' );
  gTPicture.AddMethod( 'Assign', TPicture_Assign, '' );
  gTPicture.AddMethod( 'RegisterFileFormat', TPicture_RegisterFileFormat, '' );
  gTPicture.AddMethod( 'RegisterFileFormatRes', TPicture_RegisterFileFormatRes, '' );
  gTPicture.AddMethod( 'RegisterClipboardFormat', TPicture_RegisterClipboardFormat, '' );
  gTPicture.AddMethod( 'UnregisterGraphicClass', TPicture_UnregisterGraphicClass, '' );
  // class TMetafileCanvas
  AddMethod( 'CreateMetafileCanvas', TMetafileCanvas_Create, '' );
  AddMethod( 'CreateWithCommentMetafileCanvas', TMetafileCanvas_CreateWithComment, '' );
  AddMethod( 'MetafileCanvas_GetAttr', TMetafileCanvas_GetAttr, '' );
  AddMethod( 'MetafileCanvas_SetAttr', TMetafileCanvas_SetAttr, '' );
  gTMetafileCanvas.AddMethod( 'Create', TMetafileCanvas_Create, '' );
  gTMetafileCanvas.AddMethod( 'CreateWithComment', TMetafileCanvas_CreateWithComment, '' );
  // class TSharedImage
  AddMethod( 'CreateSharedImage', TSharedImage_Create, '' );
  AddMethod( 'SharedImage_GetAttr', TSharedImage_GetAttr, '' );
  AddMethod( 'SharedImage_SetAttr', TSharedImage_SetAttr, '' );
  // class TMetafileImage
  AddMethod( 'CreateMetafileImage', TMetafileImage_Create, '' );
  AddMethod( 'MetafileImage_GetAttr', TMetafileImage_GetAttr, '' );
  AddMethod( 'MetafileImage_SetAttr', TMetafileImage_SetAttr, '' );
  // class TMetafile
  AddMethod( 'CreateMetafile', TMetafile_Create, '' );
  AddMethod( 'Metafile_GetAttr', TMetafile_GetAttr, '' );
  AddMethod( 'Metafile_SetAttr', TMetafile_SetAttr, '' );
  gTMetafile.AddMethod( 'Create', TMetafile_Create, '' );
  gTMetafile.AddMethod( 'Clear', TMetafile_Clear, '' );
  gTMetafile.AddMethod( 'LoadFromStream', TMetafile_LoadFromStream, '' );
  gTMetafile.AddMethod( 'SaveToFile', TMetafile_SaveToFile, '' );
  gTMetafile.AddMethod( 'SaveToStream', TMetafile_SaveToStream, '' );
  gTMetafile.AddMethod( 'LoadFromClipboardFormat', TMetafile_LoadFromClipboardFormat, '' );
  gTMetafile.AddMethod( 'SaveToClipboardFormat', TMetafile_SaveToClipboardFormat, '' );
  gTMetafile.AddMethod( 'Assign', TMetafile_Assign, '' );
  gTMetafile.AddMethod( 'ReleaseHandle', TMetafile_ReleaseHandle, '' );
  // class TBitmapImage
  AddMethod( 'CreateBitmapImage', TBitmapImage_Create, '' );
  AddMethod( 'BitmapImage_GetAttr', TBitmapImage_GetAttr, '' );
  AddMethod( 'BitmapImage_SetAttr', TBitmapImage_SetAttr, '' );
  // class TBitmap
  AddMethod( 'CreateBitmap', TBitmap_Create, '' );
  AddMethod( 'Bitmap_GetAttr', TBitmap_GetAttr, '' );
  AddMethod( 'Bitmap_SetAttr', TBitmap_SetAttr, '' );
  gTBitmap.AddMethod( 'Create', TBitmap_Create, '' );
  gTBitmap.AddMethod( 'Assign', TBitmap_Assign, '' );
  gTBitmap.AddMethod( 'Dormant', TBitmap_Dormant, '' );
  gTBitmap.AddMethod( 'FreeImage', TBitmap_FreeImage, '' );
  gTBitmap.AddMethod( 'LoadFromClipboardFormat', TBitmap_LoadFromClipboardFormat, '' );
  gTBitmap.AddMethod( 'LoadFromStream', TBitmap_LoadFromStream, '' );
  gTBitmap.AddMethod( 'LoadFromResourceName', TBitmap_LoadFromResourceName, '' );
  gTBitmap.AddMethod( 'LoadFromResourceID', TBitmap_LoadFromResourceID, '' );
  gTBitmap.AddMethod( 'Mask', TBitmap_Mask, '' );
  gTBitmap.AddMethod( 'ReleaseHandle', TBitmap_ReleaseHandle, '' );
  gTBitmap.AddMethod( 'ReleaseMaskHandle', TBitmap_ReleaseMaskHandle, '' );
  gTBitmap.AddMethod( 'ReleasePalette', TBitmap_ReleasePalette, '' );
  gTBitmap.AddMethod( 'SaveToClipboardFormat', TBitmap_SaveToClipboardFormat, '' );
  gTBitmap.AddMethod( 'SaveToStream', TBitmap_SaveToStream, '' );
  gTBitmap.AddMethod( 'ScanLine', TBitmap_ScanLine, '' );
  // class TIconImage
  AddMethod( 'CreateIconImage', TIconImage_Create, '' );
  AddMethod( 'IconImage_GetAttr', TIconImage_GetAttr, '' );
  AddMethod( 'IconImage_SetAttr', TIconImage_SetAttr, '' );
  // class TIcon
  AddMethod( 'CreateIcon', TIcon_Create, '' );
  AddMethod( 'Icon_GetAttr', TIcon_GetAttr, '' );
  AddMethod( 'Icon_SetAttr', TIcon_SetAttr, '' );
  gTIcon.AddMethod( 'Create', TIcon_Create, '' );
  gTIcon.AddMethod( 'Assign', TIcon_Assign, '' );
  gTIcon.AddMethod( 'LoadFromClipboardFormat', TIcon_LoadFromClipboardFormat, '' );
  gTIcon.AddMethod( 'LoadFromStream', TIcon_LoadFromStream, '' );
  gTIcon.AddMethod( 'ReleaseHandle', TIcon_ReleaseHandle, '' );
  gTIcon.AddMethod( 'SaveToClipboardFormat', TIcon_SaveToClipboardFormat, '' );
  gTIcon.AddMethod( 'SaveToStream', TIcon_SaveToStream, '' );
  inherited;
end;

end.
