////
//  This file was generated by VCL Generator
//  Copyright 1998 - Morgan Martinet
//  29/06/1999 13:00:00
//  it declares the content of the module _Dialogs
////

unit Python_Dialogs;

interface

uses
   Windows,
   Graphics,
   Controls,
   Forms,
   StdCtrls,
   Dialogs,
   Messages,
   Classes,
   SysUtils,
   PythonEngine;

type
  TModule_Dialogs = class( TPythonModule )
  public
    procedure Initialize; override;
  end;

  function TCommonDialog_ReadAttribute( Self : TCommonDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCommonDialog_WriteAttribute( Self : TCommonDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TOpenDialog_ReadAttribute( Self : TOpenDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TOpenDialog_WriteAttribute( Self : TOpenDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TSaveDialog_ReadAttribute( Self : TSaveDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TSaveDialog_WriteAttribute( Self : TSaveDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TColorDialog_ReadAttribute( Self : TColorDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TColorDialog_WriteAttribute( Self : TColorDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TFontDialog_ReadAttribute( Self : TFontDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TFontDialog_WriteAttribute( Self : TFontDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TPrinterSetupDialog_ReadAttribute( Self : TPrinterSetupDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TPrinterSetupDialog_WriteAttribute( Self : TPrinterSetupDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TPrintDialog_ReadAttribute( Self : TPrintDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TPrintDialog_WriteAttribute( Self : TPrintDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TFindDialog_ReadAttribute( Self : TFindDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TFindDialog_WriteAttribute( Self : TFindDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TReplaceDialog_ReadAttribute( Self : TReplaceDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TReplaceDialog_WriteAttribute( Self : TReplaceDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;

  procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 

implementation

uses
   Delphi_Classes,
   Python_Classes,
   Delphi_Graphics,
   Python_Graphics,
   Delphi_Controls,
   Python_Controls,
   Delphi_Forms,
   Python_Forms,
   Delphi_StdCtrls,
   Python_StdCtrls,
   Delphi_System,
   Delphi_Dialogs,
   Python_System,
   Py_Misc,
   PyRecords,
   PyDelphiAssoc;

var
  IsInitialized : Boolean;
  gDialogs : TModule_Dialogs;
  gTCommonDialog : TMethodsContainer;
  gTOpenDialog : TMethodsContainer;
  gTSaveDialog : TMethodsContainer;
  gTColorDialog : TMethodsContainer;
  gTFontDialog : TMethodsContainer;
  gTPrinterSetupDialog : TMethodsContainer;
  gTPrintDialog : TMethodsContainer;
  gTFindDialog : TMethodsContainer;
  gTReplaceDialog : TMethodsContainer;

procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 
begin
  if IsInitialized then
    Exit;
  IsInitialized := True;
  gDialogs := TModule_Dialogs.Create( AOwner );
  with gDialogs do
    begin
      Engine := AEngine;
      ModuleName := '_Dialogs';
    end;
  gTCommonDialog := TMethodsContainer.Create( AOwner );
  gTOpenDialog := TMethodsContainer.Create( AOwner );
  gTSaveDialog := TMethodsContainer.Create( AOwner );
  gTColorDialog := TMethodsContainer.Create( AOwner );
  gTFontDialog := TMethodsContainer.Create( AOwner );
  gTPrinterSetupDialog := TMethodsContainer.Create( AOwner );
  gTPrintDialog := TMethodsContainer.Create( AOwner );
  gTFindDialog := TMethodsContainer.Create( AOwner );
  gTReplaceDialog := TMethodsContainer.Create( AOwner );
end;

///////////// Functions for class TCommonDialog //////////////////

function TCommonDialog_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCommonDialog;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCommonDialog.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCommonDialog.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCommonDialog_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCommonDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCommonDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TCommonDialog' );
      Exit;
    end;
    realObj := TCommonDialog(obj);
    // Check attribute
    Result := TCommonDialog_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCommonDialog_ReadAttribute( Self : TCommonDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCommonDialog.MethodCount > 0 then 
      Result := Py_FindMethod( gTCommonDialog.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else if CompareText( key, 'Ctl3D' ) = 0 then Result := VariantAsPyObject( Self.Ctl3D )
    else if CompareText( key, 'HelpContext' ) = 0 then Result := VariantAsPyObject( Integer( Self.HelpContext ) )
    else if CompareText( key, 'OnClose' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnShow' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCommonDialog_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCommonDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCommonDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TCommonDialog' );
      Exit;
    end;
    realObj := TCommonDialog(obj);
    // Check attribute
    Result := TCommonDialog_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCommonDialog_WriteAttribute( Self : TCommonDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Ctl3D' ) = 0 then begin
      Self.Ctl3D := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HelpContext' ) = 0 then begin
      Self.HelpContext := THelpContext(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnClose' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnClose := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCommonDialog then
          with TPyCommonDialog(Self) do
            OnClose := EventOnClose;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnShow' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnShow := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCommonDialog then
          with TPyCommonDialog(Self) do
            OnShow := EventOnShow;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TOpenDialog //////////////////

function TOpenDialog_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyOpenDialog;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TOpenDialog.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyOpenDialog.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TOpenDialog_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TOpenDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TOpenDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TOpenDialog' );
      Exit;
    end;
    realObj := TOpenDialog(obj);
    // Check attribute
    Result := TOpenDialog_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TOpenDialog_ReadAttribute( Self : TOpenDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpOptions : TOpenOptions;
begin
  with GetPythonEngine do begin
    if gTOpenDialog.MethodCount > 0 then 
      Result := Py_FindMethod( gTOpenDialog.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'FileEditStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.FileEditStyle ) )
    else if CompareText( key, 'Files' ) = 0 then Result := GetPythonObject( Self.Files, 'Dialogs', 'TStrings' )
    else if CompareText( key, 'HistoryList' ) = 0 then Result := GetPythonObject( Self.HistoryList, 'Dialogs', 'TStrings' )
    else if CompareText( key, 'DefaultExt' ) = 0 then Result := VariantAsPyObject( Self.DefaultExt )
    else if CompareText( key, 'FileName' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TFileName' ); Result := nil; end
    else if CompareText( key, 'Filter' ) = 0 then Result := VariantAsPyObject( Self.Filter )
    else if CompareText( key, 'FilterIndex' ) = 0 then Result := VariantAsPyObject( Self.FilterIndex )
    else if CompareText( key, 'InitialDir' ) = 0 then Result := VariantAsPyObject( Self.InitialDir )
    else if CompareText( key, 'Options' ) = 0 then begin
      tmpOptions := Self.Options;
      Result := SetToList( @tmpOptions, sizeof(tmpOptions) )
    end
    else if CompareText( key, 'Title' ) = 0 then Result := VariantAsPyObject( Self.Title )
    else if CompareText( key, 'OnFolderChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnSelectionChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnTypeChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TCommonDialog_ReadAttribute( Self, argSelf, key );
  end;
end;

function TOpenDialog_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TOpenDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TOpenDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TOpenDialog' );
      Exit;
    end;
    realObj := TOpenDialog(obj);
    // Check attribute
    Result := TOpenDialog_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TOpenDialog_WriteAttribute( Self : TOpenDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpOptions : TOpenOptions;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'FileEditStyle' ) = 0 then begin
      Self.FileEditStyle := TFileEditStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Files' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'HistoryList' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TStrings then begin
        Self.HistoryList := TStrings( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'HistoryList', 'TStrings' );
    end else if CompareText( key, 'DefaultExt' ) = 0 then begin
      Self.DefaultExt := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'FileName' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'TFileName' );
    end else if CompareText( key, 'Filter' ) = 0 then begin
      Self.Filter := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'FilterIndex' ) = 0 then begin
      Self.FilterIndex := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'InitialDir' ) = 0 then begin
      Self.InitialDir := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Options' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpOptions, sizeof(tmpOptions) );
        Self.Options := tmpOptions;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Options', 'TOpenOptions' );
    end else if CompareText( key, 'Title' ) = 0 then begin
      Self.Title := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnFolderChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnFolderChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyOpenDialog then
          with TPyOpenDialog(Self) do
            OnFolderChange := EventOnFolderChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnSelectionChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnSelectionChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyOpenDialog then
          with TPyOpenDialog(Self) do
            OnSelectionChange := EventOnSelectionChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnTypeChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnTypeChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyOpenDialog then
          with TPyOpenDialog(Self) do
            OnTypeChange := EventOnTypeChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TCommonDialog_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TOpenDialog_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TOpenDialog;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TOpenDialog) then begin
      ErrorWrongExpectedType( Self, 'TOpenDialog' );
      Exit;
    end;
    realObj := TOpenDialog(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TSaveDialog //////////////////

function TSaveDialog_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPySaveDialog;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TSaveDialog.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPySaveDialog.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TSaveDialog_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TSaveDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TSaveDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TSaveDialog' );
      Exit;
    end;
    realObj := TSaveDialog(obj);
    // Check attribute
    Result := TSaveDialog_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TSaveDialog_ReadAttribute( Self : TSaveDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTSaveDialog.MethodCount > 0 then 
      Result := Py_FindMethod( gTSaveDialog.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TOpenDialog_ReadAttribute( Self, argSelf, key );
  end;
end;

function TSaveDialog_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TSaveDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TSaveDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TSaveDialog' );
      Exit;
    end;
    realObj := TSaveDialog(obj);
    // Check attribute
    Result := TSaveDialog_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TSaveDialog_WriteAttribute( Self : TSaveDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TOpenDialog_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TSaveDialog_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TSaveDialog;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TSaveDialog) then begin
      ErrorWrongExpectedType( Self, 'TSaveDialog' );
      Exit;
    end;
    realObj := TSaveDialog(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TColorDialog //////////////////

function TColorDialog_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyColorDialog;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TColorDialog.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyColorDialog.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TColorDialog_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TColorDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TColorDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TColorDialog' );
      Exit;
    end;
    realObj := TColorDialog(obj);
    // Check attribute
    Result := TColorDialog_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TColorDialog_ReadAttribute( Self : TColorDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpOptions : TColorDialogOptions;
begin
  with GetPythonEngine do begin
    if gTColorDialog.MethodCount > 0 then 
      Result := Py_FindMethod( gTColorDialog.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Ctl3D' ) = 0 then Result := VariantAsPyObject( Self.Ctl3D )
    else if CompareText( key, 'CustomColors' ) = 0 then Result := GetPythonObject( Self.CustomColors, 'Dialogs', 'TStrings' )
    else if CompareText( key, 'Options' ) = 0 then begin
      tmpOptions := Self.Options;
      Result := SetToList( @tmpOptions, sizeof(tmpOptions) )
    end
    else Result := TCommonDialog_ReadAttribute( Self, argSelf, key );
  end;
end;

function TColorDialog_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TColorDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TColorDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TColorDialog' );
      Exit;
    end;
    realObj := TColorDialog(obj);
    // Check attribute
    Result := TColorDialog_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TColorDialog_WriteAttribute( Self : TColorDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpOptions : TColorDialogOptions;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Ctl3D' ) = 0 then begin
      Self.Ctl3D := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'CustomColors' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TStrings then begin
        Self.CustomColors := TStrings( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'CustomColors', 'TStrings' );
    end else if CompareText( key, 'Options' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpOptions, sizeof(tmpOptions) );
        Self.Options := tmpOptions;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Options', 'TColorDialogOptions' );
    end else Result := TCommonDialog_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TColorDialog_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TColorDialog;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TColorDialog) then begin
      ErrorWrongExpectedType( Self, 'TColorDialog' );
      Exit;
    end;
    realObj := TColorDialog(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TFontDialog //////////////////

function TFontDialog_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyFontDialog;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TFontDialog.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyFontDialog.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TFontDialog_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFontDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFontDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TFontDialog' );
      Exit;
    end;
    realObj := TFontDialog(obj);
    // Check attribute
    Result := TFontDialog_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TFontDialog_ReadAttribute( Self : TFontDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpOptions : TFontDialogOptions;
begin
  with GetPythonEngine do begin
    if gTFontDialog.MethodCount > 0 then 
      Result := Py_FindMethod( gTFontDialog.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Font' ) = 0 then Result := GetPythonObject( Self.Font, 'Dialogs', 'TFont' )
    else if CompareText( key, 'Device' ) = 0 then Result := VariantAsPyObject( Integer( Self.Device ) )
    else if CompareText( key, 'MinFontSize' ) = 0 then Result := VariantAsPyObject( Self.MinFontSize )
    else if CompareText( key, 'MaxFontSize' ) = 0 then Result := VariantAsPyObject( Self.MaxFontSize )
    else if CompareText( key, 'Options' ) = 0 then begin
      tmpOptions := Self.Options;
      Result := SetToList( @tmpOptions, sizeof(tmpOptions) )
    end
    else if CompareText( key, 'OnApply' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TFDApplyEvent' ); Result := nil; end
    else Result := TCommonDialog_ReadAttribute( Self, argSelf, key );
  end;
end;

function TFontDialog_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFontDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFontDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TFontDialog' );
      Exit;
    end;
    realObj := TFontDialog(obj);
    // Check attribute
    Result := TFontDialog_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TFontDialog_WriteAttribute( Self : TFontDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpOptions : TFontDialogOptions;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Font' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TFont then begin
        Self.Font := TFont( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Font', 'TFont' );
    end else if CompareText( key, 'Device' ) = 0 then begin
      Self.Device := TFontDialogDevice(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MinFontSize' ) = 0 then begin
      Self.MinFontSize := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MaxFontSize' ) = 0 then begin
      Self.MaxFontSize := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Options' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpOptions, sizeof(tmpOptions) );
        Self.Options := tmpOptions;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Options', 'TFontDialogOptions' );
    end else if CompareText( key, 'OnApply' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnApply := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyFontDialog then
          with TPyFontDialog(Self) do
            OnApply := EventOnApply;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TCommonDialog_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TFontDialog_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TFontDialog;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TFontDialog) then begin
      ErrorWrongExpectedType( Self, 'TFontDialog' );
      Exit;
    end;
    realObj := TFontDialog(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TPrinterSetupDialog //////////////////

function TPrinterSetupDialog_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyPrinterSetupDialog;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TPrinterSetupDialog.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyPrinterSetupDialog.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TPrinterSetupDialog_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPrinterSetupDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPrinterSetupDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TPrinterSetupDialog' );
      Exit;
    end;
    realObj := TPrinterSetupDialog(obj);
    // Check attribute
    Result := TPrinterSetupDialog_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TPrinterSetupDialog_ReadAttribute( Self : TPrinterSetupDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTPrinterSetupDialog.MethodCount > 0 then 
      Result := Py_FindMethod( gTPrinterSetupDialog.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else Result := TCommonDialog_ReadAttribute( Self, argSelf, key );
  end;
end;

function TPrinterSetupDialog_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPrinterSetupDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPrinterSetupDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TPrinterSetupDialog' );
      Exit;
    end;
    realObj := TPrinterSetupDialog(obj);
    // Check attribute
    Result := TPrinterSetupDialog_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TPrinterSetupDialog_WriteAttribute( Self : TPrinterSetupDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else Result := TCommonDialog_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TPrinterSetupDialog_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPrinterSetupDialog;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPrinterSetupDialog) then begin
      ErrorWrongExpectedType( Self, 'TPrinterSetupDialog' );
      Exit;
    end;
    realObj := TPrinterSetupDialog(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TPrintDialog //////////////////

function TPrintDialog_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyPrintDialog;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TPrintDialog.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyPrintDialog.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TPrintDialog_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPrintDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPrintDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TPrintDialog' );
      Exit;
    end;
    realObj := TPrintDialog(obj);
    // Check attribute
    Result := TPrintDialog_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TPrintDialog_ReadAttribute( Self : TPrintDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpOptions : TPrintDialogOptions;
begin
  with GetPythonEngine do begin
    if gTPrintDialog.MethodCount > 0 then 
      Result := Py_FindMethod( gTPrintDialog.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Collate' ) = 0 then Result := VariantAsPyObject( Self.Collate )
    else if CompareText( key, 'Copies' ) = 0 then Result := VariantAsPyObject( Self.Copies )
    else if CompareText( key, 'FromPage' ) = 0 then Result := VariantAsPyObject( Self.FromPage )
    else if CompareText( key, 'MinPage' ) = 0 then Result := VariantAsPyObject( Self.MinPage )
    else if CompareText( key, 'MaxPage' ) = 0 then Result := VariantAsPyObject( Self.MaxPage )
    else if CompareText( key, 'Options' ) = 0 then begin
      tmpOptions := Self.Options;
      Result := SetToList( @tmpOptions, sizeof(tmpOptions) )
    end
    else if CompareText( key, 'PrintToFile' ) = 0 then Result := VariantAsPyObject( Self.PrintToFile )
    else if CompareText( key, 'PrintRange' ) = 0 then Result := VariantAsPyObject( Integer( Self.PrintRange ) )
    else if CompareText( key, 'ToPage' ) = 0 then Result := VariantAsPyObject( Self.ToPage )
    else Result := TCommonDialog_ReadAttribute( Self, argSelf, key );
  end;
end;

function TPrintDialog_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TPrintDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TPrintDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TPrintDialog' );
      Exit;
    end;
    realObj := TPrintDialog(obj);
    // Check attribute
    Result := TPrintDialog_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TPrintDialog_WriteAttribute( Self : TPrintDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpOptions : TPrintDialogOptions;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Collate' ) = 0 then begin
      Self.Collate := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Copies' ) = 0 then begin
      Self.Copies := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'FromPage' ) = 0 then begin
      Self.FromPage := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MinPage' ) = 0 then begin
      Self.MinPage := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'MaxPage' ) = 0 then begin
      Self.MaxPage := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Options' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpOptions, sizeof(tmpOptions) );
        Self.Options := tmpOptions;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Options', 'TPrintDialogOptions' );
    end else if CompareText( key, 'PrintToFile' ) = 0 then begin
      Self.PrintToFile := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PrintRange' ) = 0 then begin
      Self.PrintRange := TPrintRange(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ToPage' ) = 0 then begin
      Self.ToPage := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TCommonDialog_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TPrintDialog_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TPrintDialog;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TPrintDialog) then begin
      ErrorWrongExpectedType( Self, 'TPrintDialog' );
      Exit;
    end;
    realObj := TPrintDialog(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TFindDialog //////////////////

function TFindDialog_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyFindDialog;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TFindDialog.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyFindDialog.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TFindDialog_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFindDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFindDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TFindDialog' );
      Exit;
    end;
    realObj := TFindDialog(obj);
    // Check attribute
    Result := TFindDialog_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TFindDialog_ReadAttribute( Self : TFindDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpOptions : TFindOptions;
begin
  with GetPythonEngine do begin
    if gTFindDialog.MethodCount > 0 then 
      Result := Py_FindMethod( gTFindDialog.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Left' ) = 0 then Result := VariantAsPyObject( Self.Left )
    else if CompareText( key, 'Position' ) = 0 then Result := CreatePoint( Self.Position ).GetSelf
    else if CompareText( key, 'Top' ) = 0 then Result := VariantAsPyObject( Self.Top )
    else if CompareText( key, 'FindText' ) = 0 then Result := VariantAsPyObject( Self.FindText )
    else if CompareText( key, 'Options' ) = 0 then begin
      tmpOptions := Self.Options;
      Result := SetToList( @tmpOptions, sizeof(tmpOptions) )
    end
    else if CompareText( key, 'OnFind' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TCommonDialog_ReadAttribute( Self, argSelf, key );
  end;
end;

function TFindDialog_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TFindDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TFindDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TFindDialog' );
      Exit;
    end;
    realObj := TFindDialog(obj);
    // Check attribute
    Result := TFindDialog_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TFindDialog_WriteAttribute( Self : TFindDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpOptions : TFindOptions;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Left' ) = 0 then begin
      Self.Left := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Position' ) = 0 then begin
      Self.Position := PyObjectAsPoint( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Top' ) = 0 then begin
      Self.Top := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'FindText' ) = 0 then begin
      Self.FindText := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Options' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpOptions, sizeof(tmpOptions) );
        Self.Options := tmpOptions;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Options', 'TFindOptions' );
    end else if CompareText( key, 'OnFind' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnFind := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyFindDialog then
          with TPyFindDialog(Self) do
            OnFind := EventOnFind;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TCommonDialog_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TFindDialog_CloseDialog( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TFindDialog;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TFindDialog) then begin
      ErrorWrongExpectedType( Self, 'TFindDialog' );
      Exit;
    end;
    realObj := TFindDialog(obj);
    realObj.CloseDialog;
    Result := ReturnNone;
  end;
end;

function TFindDialog_Execute( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TFindDialog;
  rslt : Boolean;
begin
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TFindDialog) then begin
      ErrorWrongExpectedType( Self, 'TFindDialog' );
      Exit;
    end;
    realObj := TFindDialog(obj);
    rslt := realObj.Execute;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TReplaceDialog //////////////////

function TReplaceDialog_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyReplaceDialog;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TReplaceDialog.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyReplaceDialog.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TReplaceDialog_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TReplaceDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TReplaceDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TReplaceDialog' );
      Exit;
    end;
    realObj := TReplaceDialog(obj);
    // Check attribute
    Result := TReplaceDialog_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TReplaceDialog_ReadAttribute( Self : TReplaceDialog; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTReplaceDialog.MethodCount > 0 then 
      Result := Py_FindMethod( gTReplaceDialog.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'ReplaceText' ) = 0 then Result := VariantAsPyObject( Self.ReplaceText )
    else if CompareText( key, 'OnReplace' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TFindDialog_ReadAttribute( Self, argSelf, key );
  end;
end;

function TReplaceDialog_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TReplaceDialog;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TReplaceDialog) then begin
      ErrorWrongExpectedType( argSelf, 'TReplaceDialog' );
      Exit;
    end;
    realObj := TReplaceDialog(obj);
    // Check attribute
    Result := TReplaceDialog_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TReplaceDialog_WriteAttribute( Self : TReplaceDialog; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'ReplaceText' ) = 0 then begin
      Self.ReplaceText := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnReplace' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnReplace := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyReplaceDialog then
          with TPyReplaceDialog(Self) do
            OnReplace := EventOnReplace;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TFindDialog_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Initialization of the module ///////////

procedure TModule_Dialogs.Initialize;
begin
  // class TCommonDialog
  AddMethod( 'CreateCommonDialog', TCommonDialog_Create, '' );
  AddMethod( 'CommonDialog_GetAttr', TCommonDialog_GetAttr, '' );
  AddMethod( 'CommonDialog_SetAttr', TCommonDialog_SetAttr, '' );
  gTCommonDialog.AddMethod( 'Create', TCommonDialog_Create, '' );
  // class TOpenDialog
  AddMethod( 'CreateOpenDialog', TOpenDialog_Create, '' );
  AddMethod( 'OpenDialog_GetAttr', TOpenDialog_GetAttr, '' );
  AddMethod( 'OpenDialog_SetAttr', TOpenDialog_SetAttr, '' );
  gTOpenDialog.AddMethod( 'Create', TOpenDialog_Create, '' );
  gTOpenDialog.AddMethod( 'Execute', TOpenDialog_Execute, '' );
  // class TSaveDialog
  AddMethod( 'CreateSaveDialog', TSaveDialog_Create, '' );
  AddMethod( 'SaveDialog_GetAttr', TSaveDialog_GetAttr, '' );
  AddMethod( 'SaveDialog_SetAttr', TSaveDialog_SetAttr, '' );
  gTSaveDialog.AddMethod( 'Execute', TSaveDialog_Execute, '' );
  // class TColorDialog
  AddMethod( 'CreateColorDialog', TColorDialog_Create, '' );
  AddMethod( 'ColorDialog_GetAttr', TColorDialog_GetAttr, '' );
  AddMethod( 'ColorDialog_SetAttr', TColorDialog_SetAttr, '' );
  gTColorDialog.AddMethod( 'Create', TColorDialog_Create, '' );
  gTColorDialog.AddMethod( 'Execute', TColorDialog_Execute, '' );
  // class TFontDialog
  AddMethod( 'CreateFontDialog', TFontDialog_Create, '' );
  AddMethod( 'FontDialog_GetAttr', TFontDialog_GetAttr, '' );
  AddMethod( 'FontDialog_SetAttr', TFontDialog_SetAttr, '' );
  gTFontDialog.AddMethod( 'Create', TFontDialog_Create, '' );
  gTFontDialog.AddMethod( 'Execute', TFontDialog_Execute, '' );
  // class TPrinterSetupDialog
  AddMethod( 'CreatePrinterSetupDialog', TPrinterSetupDialog_Create, '' );
  AddMethod( 'PrinterSetupDialog_GetAttr', TPrinterSetupDialog_GetAttr, '' );
  AddMethod( 'PrinterSetupDialog_SetAttr', TPrinterSetupDialog_SetAttr, '' );
  gTPrinterSetupDialog.AddMethod( 'Execute', TPrinterSetupDialog_Execute, '' );
  // class TPrintDialog
  AddMethod( 'CreatePrintDialog', TPrintDialog_Create, '' );
  AddMethod( 'PrintDialog_GetAttr', TPrintDialog_GetAttr, '' );
  AddMethod( 'PrintDialog_SetAttr', TPrintDialog_SetAttr, '' );
  gTPrintDialog.AddMethod( 'Execute', TPrintDialog_Execute, '' );
  // class TFindDialog
  AddMethod( 'CreateFindDialog', TFindDialog_Create, '' );
  AddMethod( 'FindDialog_GetAttr', TFindDialog_GetAttr, '' );
  AddMethod( 'FindDialog_SetAttr', TFindDialog_SetAttr, '' );
  gTFindDialog.AddMethod( 'Create', TFindDialog_Create, '' );
  gTFindDialog.AddMethod( 'CloseDialog', TFindDialog_CloseDialog, '' );
  gTFindDialog.AddMethod( 'Execute', TFindDialog_Execute, '' );
  // class TReplaceDialog
  AddMethod( 'CreateReplaceDialog', TReplaceDialog_Create, '' );
  AddMethod( 'ReplaceDialog_GetAttr', TReplaceDialog_GetAttr, '' );
  AddMethod( 'ReplaceDialog_SetAttr', TReplaceDialog_SetAttr, '' );
  gTReplaceDialog.AddMethod( 'Create', TReplaceDialog_Create, '' );
  inherited;
end;

end.
