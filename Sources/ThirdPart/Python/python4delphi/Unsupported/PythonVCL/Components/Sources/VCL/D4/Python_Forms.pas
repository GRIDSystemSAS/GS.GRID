////
//  This file was generated by VCL Generator
//  Copyright 1998 - Morgan Martinet
//  06/07/1999 07:58:52
//  it declares the content of the module _Forms
////

unit Python_Forms;

interface

uses
   Windows,
   Graphics,
   Menus,
   Controls,
   ActnList,
   Forms,
   Messages,
   Classes,
   SysUtils,
   PythonEngine;

type
  TModule_Forms = class( TPythonModule )
  public
    procedure Initialize; override;
  end;

  function TControlScrollBar_ReadAttribute( Self : TControlScrollBar; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TControlScrollBar_WriteAttribute( Self : TControlScrollBar; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TScrollingWinControl_ReadAttribute( Self : TScrollingWinControl; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TScrollingWinControl_WriteAttribute( Self : TScrollingWinControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TScrollBox_ReadAttribute( Self : TScrollBox; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TScrollBox_WriteAttribute( Self : TScrollBox; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCustomForm_ReadAttribute( Self : TCustomForm; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCustomForm_WriteAttribute( Self : TCustomForm; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCustomActiveForm_ReadAttribute( Self : TCustomActiveForm; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCustomActiveForm_WriteAttribute( Self : TCustomActiveForm; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TForm_ReadAttribute( Self : TForm; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TForm_WriteAttribute( Self : TForm; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TCustomDockForm_ReadAttribute( Self : TCustomDockForm; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TCustomDockForm_WriteAttribute( Self : TCustomDockForm; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TDataModule_ReadAttribute( Self : TDataModule; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TDataModule_WriteAttribute( Self : TDataModule; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TMonitor_ReadAttribute( Self : TMonitor; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TMonitor_WriteAttribute( Self : TMonitor; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TScreen_ReadAttribute( Self : TScreen; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TScreen_WriteAttribute( Self : TScreen; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
  function TApplication_ReadAttribute( Self : TApplication; argSelf : PPyObject; key : PChar ) : PPyObject;
  function TApplication_WriteAttribute( Self : TApplication; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;

  procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 

implementation

uses
   Delphi_Classes,
   Python_Classes,
   Delphi_Graphics,
   Python_Graphics,
   Delphi_Menus,
   Python_Menus,
   Delphi_Controls,
   Python_Controls,
   Delphi_ActnList,
   Python_ActnList,
   Delphi_System,
   Delphi_Forms,
   Python_System,
   Py_Misc,
   PyRecords,
   PyDelphiAssoc;

var
  IsInitialized : Boolean;
  gForms : TModule_Forms;
  gTControlScrollBar : TMethodsContainer;
  gTScrollingWinControl : TMethodsContainer;
  gTScrollBox : TMethodsContainer;
  gTCustomForm : TMethodsContainer;
  gTCustomActiveForm : TMethodsContainer;
  gTForm : TMethodsContainer;
  gTCustomDockForm : TMethodsContainer;
  gTDataModule : TMethodsContainer;
  gTMonitor : TMethodsContainer;
  gTScreen : TMethodsContainer;
  gTApplication : TMethodsContainer;

procedure Init( AOwner : TComponent; AEngine : TPythonEngine ); 
begin
  if IsInitialized then
    Exit;
  IsInitialized := True;
  gForms := TModule_Forms.Create( AOwner );
  with gForms do
    begin
      Engine := AEngine;
      ModuleName := '_Forms';
    end;
  gTControlScrollBar := TMethodsContainer.Create( AOwner );
  gTScrollingWinControl := TMethodsContainer.Create( AOwner );
  gTScrollBox := TMethodsContainer.Create( AOwner );
  gTCustomForm := TMethodsContainer.Create( AOwner );
  gTCustomActiveForm := TMethodsContainer.Create( AOwner );
  gTForm := TMethodsContainer.Create( AOwner );
  gTCustomDockForm := TMethodsContainer.Create( AOwner );
  gTDataModule := TMethodsContainer.Create( AOwner );
  gTMonitor := TMethodsContainer.Create( AOwner );
  gTScreen := TMethodsContainer.Create( AOwner );
  gTApplication := TMethodsContainer.Create( AOwner );
end;

///////////// Functions for class TControlScrollBar //////////////////

function TControlScrollBar_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyControlScrollBar;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TControlScrollBar.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyControlScrollBar.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TControlScrollBar_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControlScrollBar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControlScrollBar) then begin
      ErrorWrongExpectedType( argSelf, 'TControlScrollBar' );
      Exit;
    end;
    realObj := TControlScrollBar(obj);
    // Check attribute
    Result := TControlScrollBar_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TControlScrollBar_ReadAttribute( Self : TControlScrollBar; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTControlScrollBar.MethodCount > 0 then 
      Result := Py_FindMethod( gTControlScrollBar.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Kind' ) = 0 then Result := VariantAsPyObject( Integer( Self.Kind ) )
    else if CompareText( key, 'ScrollPos' ) = 0 then Result := VariantAsPyObject( Self.ScrollPos )
    else if CompareText( key, 'ButtonSize' ) = 0 then Result := VariantAsPyObject( Self.ButtonSize )
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Increment' ) = 0 then Result := VariantAsPyObject( Integer( Self.Increment ) )
    else if CompareText( key, 'Margin' ) = 0 then Result := VariantAsPyObject( Self.Margin )
    else if CompareText( key, 'ParentColor' ) = 0 then Result := VariantAsPyObject( Self.ParentColor )
    else if CompareText( key, 'Position' ) = 0 then Result := VariantAsPyObject( Self.Position )
    else if CompareText( key, 'Range' ) = 0 then Result := VariantAsPyObject( Self.Range )
    else if CompareText( key, 'Smooth' ) = 0 then Result := VariantAsPyObject( Self.Smooth )
    else if CompareText( key, 'Size' ) = 0 then Result := VariantAsPyObject( Self.Size )
    else if CompareText( key, 'Style' ) = 0 then Result := VariantAsPyObject( Integer( Self.Style ) )
    else if CompareText( key, 'ThumbSize' ) = 0 then Result := VariantAsPyObject( Self.ThumbSize )
    else if CompareText( key, 'Tracking' ) = 0 then Result := VariantAsPyObject( Self.Tracking )
    else if CompareText( key, 'Visible' ) = 0 then Result := VariantAsPyObject( Self.Visible )
    else Result := TPersistent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TControlScrollBar_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TControlScrollBar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TControlScrollBar) then begin
      ErrorWrongExpectedType( argSelf, 'TControlScrollBar' );
      Exit;
    end;
    realObj := TControlScrollBar(obj);
    // Check attribute
    Result := TControlScrollBar_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TControlScrollBar_WriteAttribute( Self : TControlScrollBar; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Kind' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ScrollPos' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ButtonSize' ) = 0 then begin
      Self.ButtonSize := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Increment' ) = 0 then begin
      Self.Increment := TScrollBarInc(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Margin' ) = 0 then begin
      Self.Margin := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ParentColor' ) = 0 then begin
      Self.ParentColor := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Position' ) = 0 then begin
      Self.Position := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Range' ) = 0 then begin
      Self.Range := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Smooth' ) = 0 then begin
      Self.Smooth := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Size' ) = 0 then begin
      Self.Size := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Style' ) = 0 then begin
      Self.Style := TScrollBarStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ThumbSize' ) = 0 then begin
      Self.ThumbSize := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Tracking' ) = 0 then begin
      Self.Tracking := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Visible' ) = 0 then begin
      Self.Visible := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TPersistent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TControlScrollBar_Assign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControlScrollBar;
  _argSource : PPyObject;
  _objSource : TPersistent;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TControlScrollBar.Assign', [ 
                  @_argSource       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSource := GetObjectOf( _argSource ) as TPersistent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControlScrollBar) then begin
      ErrorWrongExpectedType( Self, 'TControlScrollBar' );
      Exit;
    end;
    realObj := TControlScrollBar(obj);
    realObj.Assign( _objSource );
    Result := ReturnNone;
  end;
end;

function TControlScrollBar_ChangeBiDiPosition( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControlScrollBar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControlScrollBar) then begin
      ErrorWrongExpectedType( Self, 'TControlScrollBar' );
      Exit;
    end;
    realObj := TControlScrollBar(obj);
    realObj.ChangeBiDiPosition;
    Result := ReturnNone;
  end;
end;

function TControlScrollBar_IsScrollBarVisible( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TControlScrollBar;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TControlScrollBar) then begin
      ErrorWrongExpectedType( Self, 'TControlScrollBar' );
      Exit;
    end;
    realObj := TControlScrollBar(obj);
    rslt := realObj.IsScrollBarVisible;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Functions for class TScrollingWinControl //////////////////

function TScrollingWinControl_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyScrollingWinControl;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TScrollingWinControl.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyScrollingWinControl.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TScrollingWinControl_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyScrollingWinControl;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TScrollingWinControl.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyScrollingWinControl.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TScrollingWinControl_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TScrollingWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TScrollingWinControl) then begin
      ErrorWrongExpectedType( argSelf, 'TScrollingWinControl' );
      Exit;
    end;
    realObj := TScrollingWinControl(obj);
    // Check attribute
    Result := TScrollingWinControl_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TScrollingWinControl_ReadAttribute( Self : TScrollingWinControl; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTScrollingWinControl.MethodCount > 0 then 
      Result := Py_FindMethod( gTScrollingWinControl.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'HorzScrollBar' ) = 0 then Result := GetPythonObject( Self.HorzScrollBar, 'Forms', 'TControlScrollBar' )
    else if CompareText( key, 'VertScrollBar' ) = 0 then Result := GetPythonObject( Self.VertScrollBar, 'Forms', 'TControlScrollBar' )
    else Result := TWinControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function TScrollingWinControl_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TScrollingWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TScrollingWinControl) then begin
      ErrorWrongExpectedType( argSelf, 'TScrollingWinControl' );
      Exit;
    end;
    realObj := TScrollingWinControl(obj);
    // Check attribute
    Result := TScrollingWinControl_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TScrollingWinControl_WriteAttribute( Self : TScrollingWinControl; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'HorzScrollBar' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TControlScrollBar then begin
        Self.HorzScrollBar := TControlScrollBar( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'HorzScrollBar', 'TControlScrollBar' );
    end else if CompareText( key, 'VertScrollBar' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TControlScrollBar then begin
        Self.VertScrollBar := TControlScrollBar( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'VertScrollBar', 'TControlScrollBar' );
    end else Result := TWinControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TScrollingWinControl_DisableAutoRange( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScrollingWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScrollingWinControl) then begin
      ErrorWrongExpectedType( Self, 'TScrollingWinControl' );
      Exit;
    end;
    realObj := TScrollingWinControl(obj);
    realObj.DisableAutoRange;
    Result := ReturnNone;
  end;
end;

function TScrollingWinControl_EnableAutoRange( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScrollingWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScrollingWinControl) then begin
      ErrorWrongExpectedType( Self, 'TScrollingWinControl' );
      Exit;
    end;
    realObj := TScrollingWinControl(obj);
    realObj.EnableAutoRange;
    Result := ReturnNone;
  end;
end;

function TScrollingWinControl_ScrollInView( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScrollingWinControl;
  _argAControl : PPyObject;
  _objAControl : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TScrollingWinControl.ScrollInView', [ 
                  @_argAControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAControl := GetObjectOf( _argAControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScrollingWinControl) then begin
      ErrorWrongExpectedType( Self, 'TScrollingWinControl' );
      Exit;
    end;
    realObj := TScrollingWinControl(obj);
    realObj.ScrollInView( _objAControl );
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TScrollBox //////////////////

function TScrollBox_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyScrollBox;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TScrollBox.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyScrollBox.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TScrollBox_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyScrollBox;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TScrollBox.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyScrollBox.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TScrollBox_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TScrollBox;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TScrollBox) then begin
      ErrorWrongExpectedType( argSelf, 'TScrollBox' );
      Exit;
    end;
    realObj := TScrollBox(obj);
    // Check attribute
    Result := TScrollBox_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TScrollBox_ReadAttribute( Self : TScrollBox; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpAnchors : TAnchors;
begin
  with GetPythonEngine do begin
    if gTScrollBox.MethodCount > 0 then 
      Result := Py_FindMethod( gTScrollBox.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Align' ) = 0 then Result := VariantAsPyObject( Integer( Self.Align ) )
    else if CompareText( key, 'Anchors' ) = 0 then begin
      tmpAnchors := Self.Anchors;
      Result := SetToList( @tmpAnchors, sizeof(tmpAnchors) )
    end
    else if CompareText( key, 'AutoScroll' ) = 0 then Result := VariantAsPyObject( Self.AutoScroll )
    else if CompareText( key, 'AutoSize' ) = 0 then Result := VariantAsPyObject( Self.AutoSize )
    else if CompareText( key, 'BiDiMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.BiDiMode ) )
    else if CompareText( key, 'BorderStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.BorderStyle ) )
    else if CompareText( key, 'Constraints' ) = 0 then Result := GetPythonObject( Self.Constraints, 'Forms', 'TSizeConstraints' )
    else if CompareText( key, 'DockSite' ) = 0 then Result := VariantAsPyObject( Self.DockSite )
    else if CompareText( key, 'DragCursor' ) = 0 then Result := VariantAsPyObject( Integer( Self.DragCursor ) )
    else if CompareText( key, 'DragKind' ) = 0 then Result := VariantAsPyObject( Integer( Self.DragKind ) )
    else if CompareText( key, 'DragMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.DragMode ) )
    else if CompareText( key, 'Enabled' ) = 0 then Result := VariantAsPyObject( Self.Enabled )
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Ctl3D' ) = 0 then Result := VariantAsPyObject( Self.Ctl3D )
    else if CompareText( key, 'Font' ) = 0 then Result := GetPythonObject( Self.Font, 'Forms', 'TFont' )
    else if CompareText( key, 'ParentBiDiMode' ) = 0 then Result := VariantAsPyObject( Self.ParentBiDiMode )
    else if CompareText( key, 'ParentColor' ) = 0 then Result := VariantAsPyObject( Self.ParentColor )
    else if CompareText( key, 'ParentCtl3D' ) = 0 then Result := VariantAsPyObject( Self.ParentCtl3D )
    else if CompareText( key, 'ParentFont' ) = 0 then Result := VariantAsPyObject( Self.ParentFont )
    else if CompareText( key, 'ParentShowHint' ) = 0 then Result := VariantAsPyObject( Self.ParentShowHint )
    else if CompareText( key, 'PopupMenu' ) = 0 then Result := GetPythonObject( Self.PopupMenu, 'Forms', 'TPopupMenu' )
    else if CompareText( key, 'ShowHint' ) = 0 then Result := VariantAsPyObject( Self.ShowHint )
    else if CompareText( key, 'TabOrder' ) = 0 then Result := VariantAsPyObject( Integer( Self.TabOrder ) )
    else if CompareText( key, 'TabStop' ) = 0 then Result := VariantAsPyObject( Self.TabStop )
    else if CompareText( key, 'Visible' ) = 0 then Result := VariantAsPyObject( Self.Visible )
    else if CompareText( key, 'OnCanResize' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TCanResizeEvent' ); Result := nil; end
    else if CompareText( key, 'OnClick' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnConstrainedResize' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TConstrainedResizeEvent' ); Result := nil; end
    else if CompareText( key, 'OnDblClick' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDockDrop' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDockDropEvent' ); Result := nil; end
    else if CompareText( key, 'OnDockOver' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDockOverEvent' ); Result := nil; end
    else if CompareText( key, 'OnDragDrop' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDragDropEvent' ); Result := nil; end
    else if CompareText( key, 'OnDragOver' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDragOverEvent' ); Result := nil; end
    else if CompareText( key, 'OnEndDock' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TEndDragEvent' ); Result := nil; end
    else if CompareText( key, 'OnEndDrag' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TEndDragEvent' ); Result := nil; end
    else if CompareText( key, 'OnEnter' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnExit' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnGetSiteInfo' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TGetSiteInfoEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseDown' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseMove' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseMoveEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseUp' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseWheel' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseWheelEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseWheelDown' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseWheelUpDownEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseWheelUp' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseWheelUpDownEvent' ); Result := nil; end
    else if CompareText( key, 'OnResize' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnStartDock' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TStartDockEvent' ); Result := nil; end
    else if CompareText( key, 'OnStartDrag' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TStartDragEvent' ); Result := nil; end
    else if CompareText( key, 'OnUnDock' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TUnDockEvent' ); Result := nil; end
    else Result := TScrollingWinControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function TScrollBox_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TScrollBox;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TScrollBox) then begin
      ErrorWrongExpectedType( argSelf, 'TScrollBox' );
      Exit;
    end;
    realObj := TScrollBox(obj);
    // Check attribute
    Result := TScrollBox_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TScrollBox_WriteAttribute( Self : TScrollBox; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpAnchors : TAnchors;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Align' ) = 0 then begin
      Self.Align := TAlign(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Anchors' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpAnchors, sizeof(tmpAnchors) );
        Self.Anchors := tmpAnchors;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Anchors', 'TAnchors' );
    end else if CompareText( key, 'AutoScroll' ) = 0 then begin
      Self.AutoScroll := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'AutoSize' ) = 0 then begin
      Self.AutoSize := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BiDiMode' ) = 0 then begin
      Self.BiDiMode := TBiDiMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BorderStyle' ) = 0 then begin
      Self.BorderStyle := TBorderStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Constraints' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TSizeConstraints then begin
        Self.Constraints := TSizeConstraints( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Constraints', 'TSizeConstraints' );
    end else if CompareText( key, 'DockSite' ) = 0 then begin
      Self.DockSite := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragCursor' ) = 0 then begin
      Self.DragCursor := TCursor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragKind' ) = 0 then begin
      Self.DragKind := TDragKind(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragMode' ) = 0 then begin
      Self.DragMode := TDragMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Enabled' ) = 0 then begin
      Self.Enabled := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Ctl3D' ) = 0 then begin
      Self.Ctl3D := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Font' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TFont then begin
        Self.Font := TFont( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Font', 'TFont' );
    end else if CompareText( key, 'ParentBiDiMode' ) = 0 then begin
      Self.ParentBiDiMode := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ParentColor' ) = 0 then begin
      Self.ParentColor := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ParentCtl3D' ) = 0 then begin
      Self.ParentCtl3D := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ParentFont' ) = 0 then begin
      Self.ParentFont := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ParentShowHint' ) = 0 then begin
      Self.ParentShowHint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PopupMenu' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TPopupMenu then begin
        Self.PopupMenu := TPopupMenu( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'PopupMenu', 'TPopupMenu' );
    end else if CompareText( key, 'ShowHint' ) = 0 then begin
      Self.ShowHint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'TabOrder' ) = 0 then begin
      Self.TabOrder := TTabOrder(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'TabStop' ) = 0 then begin
      Self.TabStop := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Visible' ) = 0 then begin
      Self.Visible := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnCanResize' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnCanResize := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnCanResize := EventOnCanResize;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnClick' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnClick := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnClick := EventOnClick;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnConstrainedResize' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnConstrainedResize := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnConstrainedResize := EventOnConstrainedResize;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDblClick' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDblClick := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnDblClick := EventOnDblClick;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDockDrop' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDockDrop := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnDockDrop := EventOnDockDrop;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDockOver' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDockOver := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnDockOver := EventOnDockOver;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDragDrop' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDragDrop := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnDragDrop := EventOnDragDrop;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDragOver' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDragOver := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnDragOver := EventOnDragOver;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnEndDock' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnEndDock := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnEndDock := EventOnEndDock;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnEndDrag' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnEndDrag := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnEndDrag := EventOnEndDrag;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnEnter' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnEnter := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnEnter := EventOnEnter;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnExit' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnExit := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnExit := EventOnExit;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnGetSiteInfo' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnGetSiteInfo := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnGetSiteInfo := EventOnGetSiteInfo;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseDown' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseDown := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnMouseDown := EventOnMouseDown;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseMove' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseMove := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnMouseMove := EventOnMouseMove;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseUp' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseUp := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnMouseUp := EventOnMouseUp;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseWheel' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseWheel := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnMouseWheel := EventOnMouseWheel;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseWheelDown' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseWheelDown := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnMouseWheelDown := EventOnMouseWheelDown;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseWheelUp' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseWheelUp := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnMouseWheelUp := EventOnMouseWheelUp;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnResize' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnResize := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnResize := EventOnResize;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnStartDock' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnStartDock := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnStartDock := EventOnStartDock;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnStartDrag' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnStartDrag := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnStartDrag := EventOnStartDrag;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnUnDock' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnUnDock := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScrollBox then
          with TPyScrollBox(Self) do
            OnUnDock := EventOnUnDock;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TScrollingWinControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TCustomForm //////////////////

function TCustomForm_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomForm;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCustomForm.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomForm.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomForm_CreateNew( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomForm;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
  _argDummy : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TCustomForm.CreateNew', [ @_argSelf,
                  @_argAOwner,
                  @_argDummy       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomForm.CreateNew( _objAOwner, Integer(_argDummy) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomForm_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomForm;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TCustomForm.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomForm.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomForm_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    // Check attribute
    Result := TCustomForm_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCustomForm_ReadAttribute( Self : TCustomForm; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpFormState : TFormState;
begin
  with GetPythonEngine do begin
    if gTCustomForm.MethodCount > 0 then 
      Result := Py_FindMethod( gTCustomForm.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Active' ) = 0 then Result := VariantAsPyObject( Self.Active )
    else if CompareText( key, 'ActiveControl' ) = 0 then Result := GetPythonObject( Self.ActiveControl, 'Forms', 'TWinControl' )
    else if CompareText( key, 'Action' ) = 0 then Result := GetPythonObject( Self.Action, 'Forms', 'TBasicAction' )
    else if CompareText( key, 'ActiveOleControl' ) = 0 then Result := GetPythonObject( Self.ActiveOleControl, 'Forms', 'TWinControl' )
    else if CompareText( key, 'BorderStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.BorderStyle ) )
    else if CompareText( key, 'Canvas' ) = 0 then Result := GetPythonObject( Self.Canvas, 'Forms', 'TCanvas' )
    else if CompareText( key, 'Caption' ) = 0 then Result := VariantAsPyObject( Self.Caption )
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Designer' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'IDesigner' ); Result := nil; end
    else if CompareText( key, 'DropTarget' ) = 0 then Result := VariantAsPyObject( Self.DropTarget )
    else if CompareText( key, 'Font' ) = 0 then Result := GetPythonObject( Self.Font, 'Forms', 'TFont' )
    else if CompareText( key, 'FormState' ) = 0 then begin
      tmpFormState := Self.FormState;
      Result := SetToList( @tmpFormState, sizeof(tmpFormState) )
    end
    else if CompareText( key, 'HelpFile' ) = 0 then Result := VariantAsPyObject( Self.HelpFile )
    else if CompareText( key, 'KeyPreview' ) = 0 then Result := VariantAsPyObject( Self.KeyPreview )
    else if CompareText( key, 'Menu' ) = 0 then Result := GetPythonObject( Self.Menu, 'Forms', 'TMainMenu' )
    else if CompareText( key, 'ModalResult' ) = 0 then Result := VariantAsPyObject( Integer( Self.ModalResult ) )
    else if CompareText( key, 'Monitor' ) = 0 then Result := GetPythonObject( Self.Monitor, 'Forms', 'TMonitor' )
    else if CompareText( key, 'OleFormObject' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'IOleForm' ); Result := nil; end
    else if CompareText( key, 'WindowState' ) = 0 then Result := VariantAsPyObject( Integer( Self.WindowState ) )
    else Result := TScrollingWinControl_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCustomForm_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    // Check attribute
    Result := TCustomForm_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCustomForm_WriteAttribute( Self : TCustomForm; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpFormState : TFormState;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Active' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ActiveControl' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TWinControl then begin
        Self.ActiveControl := TWinControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'ActiveControl', 'TWinControl' );
    end else if CompareText( key, 'Action' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBasicAction then begin
        Self.Action := TBasicAction( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Action', 'TBasicAction' );
    end else if CompareText( key, 'ActiveOleControl' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TWinControl then begin
        Self.ActiveOleControl := TWinControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'ActiveOleControl', 'TWinControl' );
    end else if CompareText( key, 'BorderStyle' ) = 0 then begin
      Self.BorderStyle := TFormBorderStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Canvas' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Caption' ) = 0 then begin
      Self.Caption := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Designer' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'IDesigner' );
    end else if CompareText( key, 'DropTarget' ) = 0 then begin
      Self.DropTarget := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Font' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TFont then begin
        Self.Font := TFont( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Font', 'TFont' );
    end else if CompareText( key, 'FormState' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'HelpFile' ) = 0 then begin
      Self.HelpFile := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'KeyPreview' ) = 0 then begin
      Self.KeyPreview := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Menu' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TMainMenu then begin
        Self.Menu := TMainMenu( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Menu', 'TMainMenu' );
    end else if CompareText( key, 'ModalResult' ) = 0 then begin
      Self.ModalResult := TModalResult(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Monitor' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'OleFormObject' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'IOleForm' );
    end else if CompareText( key, 'WindowState' ) = 0 then begin
      Self.WindowState := TWindowState(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else Result := TScrollingWinControl_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TCustomForm_AfterConstruction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.AfterConstruction;
    Result := ReturnNone;
  end;
end;

function TCustomForm_BeforeDestruction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.BeforeDestruction;
    Result := ReturnNone;
  end;
end;

function TCustomForm_Close( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.Close;
    Result := ReturnNone;
  end;
end;

function TCustomForm_CloseQuery( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    rslt := realObj.CloseQuery;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomForm_DefaultHandler( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCustomForm_DefocusControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
  _argControl : PPyObject;
  _objControl : TWinControl;
  _argRemoving : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'Oi:TCustomForm.DefocusControl', [ 
                  @_argControl,
                  @_argRemoving       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objControl := GetObjectOf( _argControl ) as TWinControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.DefocusControl( _objControl, Boolean(_argRemoving) );
    Result := ReturnNone;
  end;
end;

function TCustomForm_Dock( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
  _argNewDockSite : PPyObject;
  _objNewDockSite : TWinControl;
  _argARect : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'OO:TCustomForm.Dock', [ 
                  @_argNewDockSite,
                  @_argARect       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objNewDockSite := GetObjectOf( _argNewDockSite ) as TWinControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.Dock( _objNewDockSite, PyObjectAsRect( _argARect ) );
    Result := ReturnNone;
  end;
end;

function TCustomForm_FocusControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
  _argControl : PPyObject;
  _objControl : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomForm.FocusControl', [ 
                  @_argControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objControl := GetObjectOf( _argControl ) as TWinControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.FocusControl( _objControl );
    Result := ReturnNone;
  end;
end;

function TCustomForm_GetFormImage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
  rslt : TBitmap;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    rslt := realObj.GetFormImage;
    Result := GetPythonObject( rslt, 'Forms', 'TBitmap' );
  end;
end;

function TCustomForm_Hide( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.Hide;
    Result := ReturnNone;
  end;
end;

function TCustomForm_IsShortCut( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCustomForm_MouseWheelHandler( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TCustomForm_Print( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.Print;
    Result := ReturnNone;
  end;
end;

function TCustomForm_Release( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.Release;
    Result := ReturnNone;
  end;
end;

function TCustomForm_SendCancelMode( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
  _argSender : PPyObject;
  _objSender : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomForm.SendCancelMode', [ 
                  @_argSender       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSender := GetObjectOf( _argSender ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.SendCancelMode( _objSender );
    Result := ReturnNone;
  end;
end;

function TCustomForm_SetFocus( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.SetFocus;
    Result := ReturnNone;
  end;
end;

function TCustomForm_SetFocusedControl( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
  rslt : Boolean;
  _argControl : PPyObject;
  _objControl : TWinControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TCustomForm.SetFocusedControl', [ 
                  @_argControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objControl := GetObjectOf( _argControl ) as TWinControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    rslt := realObj.SetFocusedControl( _objControl );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomForm_Show( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    realObj.Show;
    Result := ReturnNone;
  end;
end;

function TCustomForm_ShowModal( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TCustomForm;
  rslt : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomForm) then begin
      ErrorWrongExpectedType( Self, 'TCustomForm' );
      Exit;
    end;
    realObj := TCustomForm(obj);
    rslt := realObj.ShowModal;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TCustomForm_WantChildKey( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TCustomActiveForm //////////////////

function TCustomActiveForm_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomActiveForm;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCustomActiveForm.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomActiveForm.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomActiveForm_CreateNew( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomActiveForm;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
  _argDummy : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TCustomActiveForm.CreateNew', [ @_argSelf,
                  @_argAOwner,
                  @_argDummy       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomActiveForm.CreateNew( _objAOwner, Integer(_argDummy) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomActiveForm_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomActiveForm;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TCustomActiveForm.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomActiveForm.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomActiveForm_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomActiveForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomActiveForm) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomActiveForm' );
      Exit;
    end;
    realObj := TCustomActiveForm(obj);
    // Check attribute
    Result := TCustomActiveForm_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCustomActiveForm_ReadAttribute( Self : TCustomActiveForm; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpAnchors : TAnchors;
begin
  with GetPythonEngine do begin
    if gTCustomActiveForm.MethodCount > 0 then 
      Result := Py_FindMethod( gTCustomActiveForm.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Visible' ) = 0 then Result := VariantAsPyObject( Self.Visible )
    else if CompareText( key, 'ActiveControl' ) = 0 then Result := GetPythonObject( Self.ActiveControl, 'Forms', 'TWinControl' )
    else if CompareText( key, 'Anchors' ) = 0 then begin
      tmpAnchors := Self.Anchors;
      Result := SetToList( @tmpAnchors, sizeof(tmpAnchors) )
    end
    else if CompareText( key, 'AutoScroll' ) = 0 then Result := VariantAsPyObject( Self.AutoScroll )
    else if CompareText( key, 'AutoSize' ) = 0 then Result := VariantAsPyObject( Self.AutoSize )
    else if CompareText( key, 'AxBorderStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.AxBorderStyle ) )
    else if CompareText( key, 'BorderWidth' ) = 0 then Result := VariantAsPyObject( Integer( Self.BorderWidth ) )
    else if CompareText( key, 'Caption' ) = 0 then Result := VariantAsPyObject( Self.Caption )
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Constraints' ) = 0 then Result := GetPythonObject( Self.Constraints, 'Forms', 'TSizeConstraints' )
    else if CompareText( key, 'Font' ) = 0 then Result := GetPythonObject( Self.Font, 'Forms', 'TFont' )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'HorzScrollBar' ) = 0 then Result := GetPythonObject( Self.HorzScrollBar, 'Forms', 'TControlScrollBar' )
    else if CompareText( key, 'KeyPreview' ) = 0 then Result := VariantAsPyObject( Self.KeyPreview )
    else if CompareText( key, 'OldCreateOrder' ) = 0 then Result := VariantAsPyObject( Self.OldCreateOrder )
    else if CompareText( key, 'PixelsPerInch' ) = 0 then Result := VariantAsPyObject( Self.PixelsPerInch )
    else if CompareText( key, 'PopupMenu' ) = 0 then Result := GetPythonObject( Self.PopupMenu, 'Forms', 'TPopupMenu' )
    else if CompareText( key, 'PrintScale' ) = 0 then Result := VariantAsPyObject( Integer( Self.PrintScale ) )
    else if CompareText( key, 'Scaled' ) = 0 then Result := VariantAsPyObject( Self.Scaled )
    else if CompareText( key, 'ShowHint' ) = 0 then Result := VariantAsPyObject( Self.ShowHint )
    else if CompareText( key, 'VertScrollBar' ) = 0 then Result := GetPythonObject( Self.VertScrollBar, 'Forms', 'TControlScrollBar' )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else if CompareText( key, 'OnActivate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnClick' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnCreate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDblClick' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDestroy' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDeactivate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDragDrop' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDragDropEvent' ); Result := nil; end
    else if CompareText( key, 'OnDragOver' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDragOverEvent' ); Result := nil; end
    else if CompareText( key, 'OnKeyDown' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TKeyEvent' ); Result := nil; end
    else if CompareText( key, 'OnKeyPress' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TKeyPressEvent' ); Result := nil; end
    else if CompareText( key, 'OnKeyUp' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TKeyEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseDown' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseMove' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseMoveEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseUp' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseEvent' ); Result := nil; end
    else if CompareText( key, 'OnPaint' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TCustomForm_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCustomActiveForm_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomActiveForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomActiveForm) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomActiveForm' );
      Exit;
    end;
    realObj := TCustomActiveForm(obj);
    // Check attribute
    Result := TCustomActiveForm_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCustomActiveForm_WriteAttribute( Self : TCustomActiveForm; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpAnchors : TAnchors;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Visible' ) = 0 then begin
      Self.Visible := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ActiveControl' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TWinControl then begin
        Self.ActiveControl := TWinControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'ActiveControl', 'TWinControl' );
    end else if CompareText( key, 'Anchors' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpAnchors, sizeof(tmpAnchors) );
        Self.Anchors := tmpAnchors;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Anchors', 'TAnchors' );
    end else if CompareText( key, 'AutoScroll' ) = 0 then begin
      Self.AutoScroll := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'AutoSize' ) = 0 then begin
      Self.AutoSize := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'AxBorderStyle' ) = 0 then begin
      Self.AxBorderStyle := TActiveFormBorderStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BorderWidth' ) = 0 then begin
      Self.BorderWidth := TBorderWidth(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Caption' ) = 0 then begin
      Self.Caption := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Constraints' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TSizeConstraints then begin
        Self.Constraints := TSizeConstraints( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Constraints', 'TSizeConstraints' );
    end else if CompareText( key, 'Font' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TFont then begin
        Self.Font := TFont( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Font', 'TFont' );
    end else if CompareText( key, 'Height' ) = 0 then begin
      Self.Height := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HorzScrollBar' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TControlScrollBar then begin
        Self.HorzScrollBar := TControlScrollBar( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'HorzScrollBar', 'TControlScrollBar' );
    end else if CompareText( key, 'KeyPreview' ) = 0 then begin
      Self.KeyPreview := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OldCreateOrder' ) = 0 then begin
      Self.OldCreateOrder := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PixelsPerInch' ) = 0 then begin
      Self.PixelsPerInch := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PopupMenu' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TPopupMenu then begin
        Self.PopupMenu := TPopupMenu( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'PopupMenu', 'TPopupMenu' );
    end else if CompareText( key, 'PrintScale' ) = 0 then begin
      Self.PrintScale := TPrintScale(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Scaled' ) = 0 then begin
      Self.Scaled := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ShowHint' ) = 0 then begin
      Self.ShowHint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'VertScrollBar' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TControlScrollBar then begin
        Self.VertScrollBar := TControlScrollBar( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'VertScrollBar', 'TControlScrollBar' );
    end else if CompareText( key, 'Width' ) = 0 then begin
      Self.Width := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnActivate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnActivate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnActivate := EventOnActivate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnClick' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnClick := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnClick := EventOnClick;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnCreate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnCreate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnCreate := EventOnCreate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDblClick' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDblClick := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnDblClick := EventOnDblClick;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDestroy' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDestroy := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnDestroy := EventOnDestroy;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDeactivate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDeactivate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnDeactivate := EventOnDeactivate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDragDrop' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDragDrop := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnDragDrop := EventOnDragDrop;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDragOver' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDragOver := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnDragOver := EventOnDragOver;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnKeyDown' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnKeyDown := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnKeyDown := EventOnKeyDown;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnKeyPress' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnKeyPress := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnKeyPress := EventOnKeyPress;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnKeyUp' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnKeyUp := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnKeyUp := EventOnKeyUp;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseDown' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseDown := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnMouseDown := EventOnMouseDown;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseMove' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseMove := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnMouseMove := EventOnMouseMove;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseUp' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseUp := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnMouseUp := EventOnMouseUp;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnPaint' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnPaint := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyCustomActiveForm then
          with TPyCustomActiveForm(Self) do
            OnPaint := EventOnPaint;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TCustomForm_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TCustomActiveForm_WantChildKey( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TForm //////////////////

function TForm_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyForm;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TForm.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyForm.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TForm_CreateNew( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyForm;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
  _argDummy : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TForm.CreateNew', [ @_argSelf,
                  @_argAOwner,
                  @_argDummy       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyForm.CreateNew( _objAOwner, Integer(_argDummy) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TForm_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyForm;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TForm.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyForm.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TForm_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TForm) then begin
      ErrorWrongExpectedType( argSelf, 'TForm' );
      Exit;
    end;
    realObj := TForm(obj);
    // Check attribute
    Result := TForm_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TForm_ReadAttribute( Self : TForm; argSelf : PPyObject; key : PChar ) : PPyObject;
var
  tmpAnchors : TAnchors;
  tmpBorderIcons : TBorderIcons;
begin
  with GetPythonEngine do begin
    if gTForm.MethodCount > 0 then 
      Result := Py_FindMethod( gTForm.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'ActiveMDIChild' ) = 0 then Result := GetPythonObject( Self.ActiveMDIChild, 'Forms', 'TForm' )
    else if CompareText( key, 'ClientHandle' ) = 0 then Result := VariantAsPyObject( Self.ClientHandle )
    else if CompareText( key, 'DockManager' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'IDockManager' ); Result := nil; end
    else if CompareText( key, 'MDIChildCount' ) = 0 then Result := VariantAsPyObject( Self.MDIChildCount )
    else if CompareText( key, 'TileMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.TileMode ) )
    else if CompareText( key, 'Action' ) = 0 then Result := GetPythonObject( Self.Action, 'Forms', 'TBasicAction' )
    else if CompareText( key, 'ActiveControl' ) = 0 then Result := GetPythonObject( Self.ActiveControl, 'Forms', 'TWinControl' )
    else if CompareText( key, 'Align' ) = 0 then Result := VariantAsPyObject( Integer( Self.Align ) )
    else if CompareText( key, 'Anchors' ) = 0 then begin
      tmpAnchors := Self.Anchors;
      Result := SetToList( @tmpAnchors, sizeof(tmpAnchors) )
    end
    else if CompareText( key, 'AutoScroll' ) = 0 then Result := VariantAsPyObject( Self.AutoScroll )
    else if CompareText( key, 'AutoSize' ) = 0 then Result := VariantAsPyObject( Self.AutoSize )
    else if CompareText( key, 'BiDiMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.BiDiMode ) )
    else if CompareText( key, 'BorderIcons' ) = 0 then begin
      tmpBorderIcons := Self.BorderIcons;
      Result := SetToList( @tmpBorderIcons, sizeof(tmpBorderIcons) )
    end
    else if CompareText( key, 'BorderStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.BorderStyle ) )
    else if CompareText( key, 'BorderWidth' ) = 0 then Result := VariantAsPyObject( Integer( Self.BorderWidth ) )
    else if CompareText( key, 'Caption' ) = 0 then Result := VariantAsPyObject( Self.Caption )
    else if CompareText( key, 'ClientHeight' ) = 0 then Result := VariantAsPyObject( Self.ClientHeight )
    else if CompareText( key, 'ClientWidth' ) = 0 then Result := VariantAsPyObject( Self.ClientWidth )
    else if CompareText( key, 'Color' ) = 0 then Result := VariantAsPyObject( Integer( Self.Color ) )
    else if CompareText( key, 'Constraints' ) = 0 then Result := GetPythonObject( Self.Constraints, 'Forms', 'TSizeConstraints' )
    else if CompareText( key, 'Ctl3D' ) = 0 then Result := VariantAsPyObject( Self.Ctl3D )
    else if CompareText( key, 'UseDockManager' ) = 0 then Result := VariantAsPyObject( Self.UseDockManager )
    else if CompareText( key, 'DefaultMonitor' ) = 0 then Result := VariantAsPyObject( Integer( Self.DefaultMonitor ) )
    else if CompareText( key, 'DockSite' ) = 0 then Result := VariantAsPyObject( Self.DockSite )
    else if CompareText( key, 'DragKind' ) = 0 then Result := VariantAsPyObject( Integer( Self.DragKind ) )
    else if CompareText( key, 'DragMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.DragMode ) )
    else if CompareText( key, 'Enabled' ) = 0 then Result := VariantAsPyObject( Self.Enabled )
    else if CompareText( key, 'ParentFont' ) = 0 then Result := VariantAsPyObject( Self.ParentFont )
    else if CompareText( key, 'Font' ) = 0 then Result := GetPythonObject( Self.Font, 'Forms', 'TFont' )
    else if CompareText( key, 'FormStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.FormStyle ) )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'HelpFile' ) = 0 then Result := VariantAsPyObject( Self.HelpFile )
    else if CompareText( key, 'HorzScrollBar' ) = 0 then Result := GetPythonObject( Self.HorzScrollBar, 'Forms', 'TControlScrollBar' )
    else if CompareText( key, 'Icon' ) = 0 then Result := GetPythonObject( Self.Icon, 'Forms', 'TIcon' )
    else if CompareText( key, 'KeyPreview' ) = 0 then Result := VariantAsPyObject( Self.KeyPreview )
    else if CompareText( key, 'Menu' ) = 0 then Result := GetPythonObject( Self.Menu, 'Forms', 'TMainMenu' )
    else if CompareText( key, 'OldCreateOrder' ) = 0 then Result := VariantAsPyObject( Self.OldCreateOrder )
    else if CompareText( key, 'ObjectMenuItem' ) = 0 then Result := GetPythonObject( Self.ObjectMenuItem, 'Forms', 'TMenuItem' )
    else if CompareText( key, 'ParentBiDiMode' ) = 0 then Result := VariantAsPyObject( Self.ParentBiDiMode )
    else if CompareText( key, 'PixelsPerInch' ) = 0 then Result := VariantAsPyObject( Self.PixelsPerInch )
    else if CompareText( key, 'PopupMenu' ) = 0 then Result := GetPythonObject( Self.PopupMenu, 'Forms', 'TPopupMenu' )
    else if CompareText( key, 'Position' ) = 0 then Result := VariantAsPyObject( Integer( Self.Position ) )
    else if CompareText( key, 'PrintScale' ) = 0 then Result := VariantAsPyObject( Integer( Self.PrintScale ) )
    else if CompareText( key, 'Scaled' ) = 0 then Result := VariantAsPyObject( Self.Scaled )
    else if CompareText( key, 'ShowHint' ) = 0 then Result := VariantAsPyObject( Self.ShowHint )
    else if CompareText( key, 'VertScrollBar' ) = 0 then Result := GetPythonObject( Self.VertScrollBar, 'Forms', 'TControlScrollBar' )
    else if CompareText( key, 'Visible' ) = 0 then Result := VariantAsPyObject( Self.Visible )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else if CompareText( key, 'WindowState' ) = 0 then Result := VariantAsPyObject( Integer( Self.WindowState ) )
    else if CompareText( key, 'WindowMenu' ) = 0 then Result := GetPythonObject( Self.WindowMenu, 'Forms', 'TMenuItem' )
    else if CompareText( key, 'OnActivate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnCanResize' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TCanResizeEvent' ); Result := nil; end
    else if CompareText( key, 'OnClick' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnClose' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TCloseEvent' ); Result := nil; end
    else if CompareText( key, 'OnCloseQuery' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TCloseQueryEvent' ); Result := nil; end
    else if CompareText( key, 'OnConstrainedResize' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TConstrainedResizeEvent' ); Result := nil; end
    else if CompareText( key, 'OnCreate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDblClick' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDestroy' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDeactivate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDockDrop' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDockDropEvent' ); Result := nil; end
    else if CompareText( key, 'OnDockOver' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDockOverEvent' ); Result := nil; end
    else if CompareText( key, 'OnDragDrop' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDragDropEvent' ); Result := nil; end
    else if CompareText( key, 'OnDragOver' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TDragOverEvent' ); Result := nil; end
    else if CompareText( key, 'OnEndDock' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TEndDragEvent' ); Result := nil; end
    else if CompareText( key, 'OnGetSiteInfo' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TGetSiteInfoEvent' ); Result := nil; end
    else if CompareText( key, 'OnHide' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnHelp' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'THelpEvent' ); Result := nil; end
    else if CompareText( key, 'OnKeyDown' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TKeyEvent' ); Result := nil; end
    else if CompareText( key, 'OnKeyPress' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TKeyPressEvent' ); Result := nil; end
    else if CompareText( key, 'OnKeyUp' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TKeyEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseDown' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseMove' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseMoveEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseUp' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseWheel' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseWheelEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseWheelDown' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseWheelUpDownEvent' ); Result := nil; end
    else if CompareText( key, 'OnMouseWheelUp' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMouseWheelUpDownEvent' ); Result := nil; end
    else if CompareText( key, 'OnPaint' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnResize' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnShortCut' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TShortCutEvent' ); Result := nil; end
    else if CompareText( key, 'OnShow' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnStartDock' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TStartDockEvent' ); Result := nil; end
    else if CompareText( key, 'OnUnDock' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TUnDockEvent' ); Result := nil; end
    else Result := TCustomForm_ReadAttribute( Self, argSelf, key );
  end;
end;

function TForm_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TForm) then begin
      ErrorWrongExpectedType( argSelf, 'TForm' );
      Exit;
    end;
    realObj := TForm(obj);
    // Check attribute
    Result := TForm_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TForm_WriteAttribute( Self : TForm; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
  tmpAnchors : TAnchors;
  tmpBorderIcons : TBorderIcons;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'ActiveMDIChild' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ClientHandle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DockManager' ) = 0 then begin
      ErrorTypeNotHandled( argSelf, key, 'IDockManager' );
    end else if CompareText( key, 'MDIChildCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'TileMode' ) = 0 then begin
      Self.TileMode := TTileMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Action' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TBasicAction then begin
        Self.Action := TBasicAction( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Action', 'TBasicAction' );
    end else if CompareText( key, 'ActiveControl' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TWinControl then begin
        Self.ActiveControl := TWinControl( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'ActiveControl', 'TWinControl' );
    end else if CompareText( key, 'Align' ) = 0 then begin
      Self.Align := TAlign(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Anchors' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpAnchors, sizeof(tmpAnchors) );
        Self.Anchors := tmpAnchors;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'Anchors', 'TAnchors' );
    end else if CompareText( key, 'AutoScroll' ) = 0 then begin
      Self.AutoScroll := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'AutoSize' ) = 0 then begin
      Self.AutoSize := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BiDiMode' ) = 0 then begin
      Self.BiDiMode := TBiDiMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BorderIcons' ) = 0 then begin
      if PyList_Check(value) then begin
        ListToSet( value, @tmpBorderIcons, sizeof(tmpBorderIcons) );
        Self.BorderIcons := tmpBorderIcons;
        Result := PyInt_FromLong(0);
      end else
        ErrorWrongSetPropertyType( argSelf, 'BorderIcons', 'TBorderIcons' );
    end else if CompareText( key, 'BorderStyle' ) = 0 then begin
      Self.BorderStyle := TFormBorderStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BorderWidth' ) = 0 then begin
      Self.BorderWidth := TBorderWidth(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Caption' ) = 0 then begin
      Self.Caption := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ClientHeight' ) = 0 then begin
      Self.ClientHeight := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ClientWidth' ) = 0 then begin
      Self.ClientWidth := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Color' ) = 0 then begin
      Self.Color := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Constraints' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TSizeConstraints then begin
        Self.Constraints := TSizeConstraints( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Constraints', 'TSizeConstraints' );
    end else if CompareText( key, 'Ctl3D' ) = 0 then begin
      Self.Ctl3D := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'UseDockManager' ) = 0 then begin
      Self.UseDockManager := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DefaultMonitor' ) = 0 then begin
      Self.DefaultMonitor := TDefaultMonitor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DockSite' ) = 0 then begin
      Self.DockSite := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragKind' ) = 0 then begin
      Self.DragKind := TDragKind(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DragMode' ) = 0 then begin
      Self.DragMode := TDragMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Enabled' ) = 0 then begin
      Self.Enabled := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ParentFont' ) = 0 then begin
      Self.ParentFont := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Font' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TFont then begin
        Self.Font := TFont( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Font', 'TFont' );
    end else if CompareText( key, 'FormStyle' ) = 0 then begin
      Self.FormStyle := TFormStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Height' ) = 0 then begin
      Self.Height := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HelpFile' ) = 0 then begin
      Self.HelpFile := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HorzScrollBar' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TControlScrollBar then begin
        Self.HorzScrollBar := TControlScrollBar( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'HorzScrollBar', 'TControlScrollBar' );
    end else if CompareText( key, 'Icon' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TIcon then begin
        Self.Icon := TIcon( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Icon', 'TIcon' );
    end else if CompareText( key, 'KeyPreview' ) = 0 then begin
      Self.KeyPreview := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Menu' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TMainMenu then begin
        Self.Menu := TMainMenu( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Menu', 'TMainMenu' );
    end else if CompareText( key, 'OldCreateOrder' ) = 0 then begin
      Self.OldCreateOrder := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ObjectMenuItem' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TMenuItem then begin
        Self.ObjectMenuItem := TMenuItem( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'ObjectMenuItem', 'TMenuItem' );
    end else if CompareText( key, 'ParentBiDiMode' ) = 0 then begin
      Self.ParentBiDiMode := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PixelsPerInch' ) = 0 then begin
      Self.PixelsPerInch := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PopupMenu' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TPopupMenu then begin
        Self.PopupMenu := TPopupMenu( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'PopupMenu', 'TPopupMenu' );
    end else if CompareText( key, 'Position' ) = 0 then begin
      Self.Position := TPosition(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PrintScale' ) = 0 then begin
      Self.PrintScale := TPrintScale(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Scaled' ) = 0 then begin
      Self.Scaled := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ShowHint' ) = 0 then begin
      Self.ShowHint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'VertScrollBar' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TControlScrollBar then begin
        Self.VertScrollBar := TControlScrollBar( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'VertScrollBar', 'TControlScrollBar' );
    end else if CompareText( key, 'Visible' ) = 0 then begin
      Self.Visible := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Width' ) = 0 then begin
      Self.Width := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'WindowState' ) = 0 then begin
      Self.WindowState := TWindowState(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'WindowMenu' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TMenuItem then begin
        Self.WindowMenu := TMenuItem( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'WindowMenu', 'TMenuItem' );
    end else if CompareText( key, 'OnActivate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnActivate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnActivate := EventOnActivate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnCanResize' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnCanResize := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnCanResize := EventOnCanResize;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnClick' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnClick := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnClick := EventOnClick;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnClose' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnClose := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnClose := EventOnClose;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnCloseQuery' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnCloseQuery := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnCloseQuery := EventOnCloseQuery;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnConstrainedResize' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnConstrainedResize := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnConstrainedResize := EventOnConstrainedResize;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnCreate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnCreate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnCreate := EventOnCreate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDblClick' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDblClick := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnDblClick := EventOnDblClick;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDestroy' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDestroy := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnDestroy := EventOnDestroy;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDeactivate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDeactivate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnDeactivate := EventOnDeactivate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDockDrop' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDockDrop := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnDockDrop := EventOnDockDrop;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDockOver' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDockOver := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnDockOver := EventOnDockOver;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDragDrop' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDragDrop := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnDragDrop := EventOnDragDrop;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDragOver' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDragOver := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnDragOver := EventOnDragOver;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnEndDock' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnEndDock := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnEndDock := EventOnEndDock;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnGetSiteInfo' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnGetSiteInfo := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnGetSiteInfo := EventOnGetSiteInfo;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnHide' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnHide := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnHide := EventOnHide;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnHelp' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnHelp := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnHelp := EventOnHelp;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnKeyDown' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnKeyDown := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnKeyDown := EventOnKeyDown;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnKeyPress' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnKeyPress := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnKeyPress := EventOnKeyPress;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnKeyUp' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnKeyUp := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnKeyUp := EventOnKeyUp;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseDown' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseDown := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnMouseDown := EventOnMouseDown;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseMove' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseMove := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnMouseMove := EventOnMouseMove;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseUp' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseUp := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnMouseUp := EventOnMouseUp;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseWheel' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseWheel := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnMouseWheel := EventOnMouseWheel;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseWheelDown' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseWheelDown := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnMouseWheelDown := EventOnMouseWheelDown;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMouseWheelUp' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMouseWheelUp := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnMouseWheelUp := EventOnMouseWheelUp;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnPaint' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnPaint := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnPaint := EventOnPaint;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnResize' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnResize := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnResize := EventOnResize;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnShortCut' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnShortCut := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnShortCut := EventOnShortCut;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnShow' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnShow := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnShow := EventOnShow;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnStartDock' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnStartDock := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnStartDock := EventOnStartDock;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnUnDock' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnUnDock := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyForm then
          with TPyForm(Self) do
            OnUnDock := EventOnUnDock;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TCustomForm_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TForm_ArrangeIcons( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TForm) then begin
      ErrorWrongExpectedType( Self, 'TForm' );
      Exit;
    end;
    realObj := TForm(obj);
    realObj.ArrangeIcons;
    Result := ReturnNone;
  end;
end;

function TForm_Cascade( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TForm) then begin
      ErrorWrongExpectedType( Self, 'TForm' );
      Exit;
    end;
    realObj := TForm(obj);
    realObj.Cascade;
    Result := ReturnNone;
  end;
end;

function TForm_Next( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TForm) then begin
      ErrorWrongExpectedType( Self, 'TForm' );
      Exit;
    end;
    realObj := TForm(obj);
    realObj.Next;
    Result := ReturnNone;
  end;
end;

function TForm_Previous( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TForm) then begin
      ErrorWrongExpectedType( Self, 'TForm' );
      Exit;
    end;
    realObj := TForm(obj);
    realObj.Previous;
    Result := ReturnNone;
  end;
end;

function TForm_Tile( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TForm) then begin
      ErrorWrongExpectedType( Self, 'TForm' );
      Exit;
    end;
    realObj := TForm(obj);
    realObj.Tile;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TCustomDockForm //////////////////

function TCustomDockForm_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomDockForm;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TCustomDockForm.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomDockForm.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomDockForm_CreateNew( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomDockForm;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
  _argDummy : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TCustomDockForm.CreateNew', [ @_argSelf,
                  @_argAOwner,
                  @_argDummy       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomDockForm.CreateNew( _objAOwner, Integer(_argDummy) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomDockForm_CreateParented( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyCustomDockForm;
  _argSelf : PPyObject;
  _argParentWindow : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'Oi:TCustomDockForm.CreateParented', [ @_argSelf,
                  @_argParentWindow       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyCustomDockForm.CreateParented( HWnd(_argParentWindow) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TCustomDockForm_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomDockForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomDockForm) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomDockForm' );
      Exit;
    end;
    realObj := TCustomDockForm(obj);
    // Check attribute
    Result := TCustomDockForm_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TCustomDockForm_ReadAttribute( Self : TCustomDockForm; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTCustomDockForm.MethodCount > 0 then 
      Result := Py_FindMethod( gTCustomDockForm.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'AutoScroll' ) = 0 then Result := VariantAsPyObject( Self.AutoScroll )
    else if CompareText( key, 'BorderStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.BorderStyle ) )
    else if CompareText( key, 'FormStyle' ) = 0 then Result := VariantAsPyObject( Integer( Self.FormStyle ) )
    else if CompareText( key, 'PixelsPerInch' ) = 0 then Result := VariantAsPyObject( Self.PixelsPerInch )
    else Result := TCustomForm_ReadAttribute( Self, argSelf, key );
  end;
end;

function TCustomDockForm_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TCustomDockForm;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TCustomDockForm) then begin
      ErrorWrongExpectedType( argSelf, 'TCustomDockForm' );
      Exit;
    end;
    realObj := TCustomDockForm(obj);
    // Check attribute
    Result := TCustomDockForm_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TCustomDockForm_WriteAttribute( Self : TCustomDockForm; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'AutoScroll' ) = 0 then begin
      Self.AutoScroll := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'BorderStyle' ) = 0 then begin
      Self.BorderStyle := TFormBorderStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'FormStyle' ) = 0 then begin
      Self.FormStyle := TFormStyle(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'PixelsPerInch' ) = 0 then begin
      Self.PixelsPerInch := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else Result := TCustomForm_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TDataModule //////////////////

function TDataModule_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDataModule;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TDataModule.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDataModule.Create( _objAOwner );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDataModule_CreateNew( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyDataModule;
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
  _argDummy : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OOi:TDataModule.CreateNew', [ @_argSelf,
                  @_argAOwner,
                  @_argDummy       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAOwner := GetObjectOf( _argAOwner ) as TComponent;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyDataModule.CreateNew( _objAOwner, Integer(_argDummy) );
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TDataModule_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDataModule;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDataModule) then begin
      ErrorWrongExpectedType( argSelf, 'TDataModule' );
      Exit;
    end;
    realObj := TDataModule(obj);
    // Check attribute
    Result := TDataModule_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TDataModule_ReadAttribute( Self : TDataModule; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTDataModule.MethodCount > 0 then 
      Result := Py_FindMethod( gTDataModule.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'DesignOffset' ) = 0 then Result := CreatePoint( Self.DesignOffset ).GetSelf
    else if CompareText( key, 'DesignSize' ) = 0 then Result := CreatePoint( Self.DesignSize ).GetSelf
    else if CompareText( key, 'OldCreateOrder' ) = 0 then Result := VariantAsPyObject( Self.OldCreateOrder )
    else if CompareText( key, 'OnCreate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDestroy' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TDataModule_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TDataModule;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TDataModule) then begin
      ErrorWrongExpectedType( argSelf, 'TDataModule' );
      Exit;
    end;
    realObj := TDataModule(obj);
    // Check attribute
    Result := TDataModule_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TDataModule_WriteAttribute( Self : TDataModule; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'DesignOffset' ) = 0 then begin
      Self.DesignOffset := PyObjectAsPoint( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DesignSize' ) = 0 then begin
      Self.DesignSize := PyObjectAsPoint( Value );      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OldCreateOrder' ) = 0 then begin
      Self.OldCreateOrder := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnCreate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnCreate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyDataModule then
          with TPyDataModule(Self) do
            OnCreate := EventOnCreate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDestroy' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDestroy := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyDataModule then
          with TPyDataModule(Self) do
            OnDestroy := EventOnDestroy;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TDataModule_AfterConstruction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDataModule;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDataModule) then begin
      ErrorWrongExpectedType( Self, 'TDataModule' );
      Exit;
    end;
    realObj := TDataModule(obj);
    realObj.AfterConstruction;
    Result := ReturnNone;
  end;
end;

function TDataModule_BeforeDestruction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TDataModule;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TDataModule) then begin
      ErrorWrongExpectedType( Self, 'TDataModule' );
      Exit;
    end;
    realObj := TDataModule(obj);
    realObj.BeforeDestruction;
    Result := ReturnNone;
  end;
end;

///////////// Functions for class TMonitor //////////////////

function TMonitor_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  newObj : TPyMonitor;
  _argSelf : PPyObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'O:TMonitor.Create', [ @_argSelf       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    newObj := TPyMonitor.Create;
    DefInterfaceObject( newObj, _argSelf, True );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TMonitor_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMonitor;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMonitor) then begin
      ErrorWrongExpectedType( argSelf, 'TMonitor' );
      Exit;
    end;
    realObj := TMonitor(obj);
    // Check attribute
    Result := TMonitor_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TMonitor_ReadAttribute( Self : TMonitor; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTMonitor.MethodCount > 0 then 
      Result := Py_FindMethod( gTMonitor.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Handle' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'HMONITOR' ); Result := nil; end
    else if CompareText( key, 'MonitorNum' ) = 0 then Result := VariantAsPyObject( Self.MonitorNum )
    else if CompareText( key, 'Left' ) = 0 then Result := VariantAsPyObject( Self.Left )
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'Top' ) = 0 then Result := VariantAsPyObject( Self.Top )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else Result := TObject_ReadAttribute( Self, argSelf, key );
  end;
end;

function TMonitor_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TMonitor;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TMonitor) then begin
      ErrorWrongExpectedType( argSelf, 'TMonitor' );
      Exit;
    end;
    realObj := TMonitor(obj);
    // Check attribute
    Result := TMonitor_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TMonitor_WriteAttribute( Self : TMonitor; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Handle' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'MonitorNum' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Left' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Height' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Top' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Width' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else Result := TObject_WriteAttribute( Self, argSelf, key, value );
  end;
end;

///////////// Functions for class TScreen //////////////////

function TScreen_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TScreen.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    DefInterfaceObject( Screen, _argSelf, False );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TScreen_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TScreen;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( argSelf, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    // Check attribute
    Result := TScreen_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TScreen_ReadAttribute( Self : TScreen; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTScreen.MethodCount > 0 then 
      Result := Py_FindMethod( gTScreen.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'ActiveControl' ) = 0 then Result := GetPythonObject( Self.ActiveControl, 'Forms', 'TWinControl' )
    else if CompareText( key, 'ActiveCustomForm' ) = 0 then Result := GetPythonObject( Self.ActiveCustomForm, 'Forms', 'TCustomForm' )
    else if CompareText( key, 'ActiveForm' ) = 0 then Result := GetPythonObject( Self.ActiveForm, 'Forms', 'TForm' )
    else if CompareText( key, 'CustomFormCount' ) = 0 then Result := VariantAsPyObject( Self.CustomFormCount )
    else if CompareText( key, 'Cursor' ) = 0 then Result := VariantAsPyObject( Integer( Self.Cursor ) )
    else if CompareText( key, 'DataModuleCount' ) = 0 then Result := VariantAsPyObject( Self.DataModuleCount )
    else if CompareText( key, 'MonitorCount' ) = 0 then Result := VariantAsPyObject( Self.MonitorCount )
    else if CompareText( key, 'DesktopHeight' ) = 0 then Result := VariantAsPyObject( Self.DesktopHeight )
    else if CompareText( key, 'DesktopLeft' ) = 0 then Result := VariantAsPyObject( Self.DesktopLeft )
    else if CompareText( key, 'DesktopTop' ) = 0 then Result := VariantAsPyObject( Self.DesktopTop )
    else if CompareText( key, 'DesktopWidth' ) = 0 then Result := VariantAsPyObject( Self.DesktopWidth )
    else if CompareText( key, 'IconFont' ) = 0 then Result := GetPythonObject( Self.IconFont, 'Forms', 'TFont' )
    else if CompareText( key, 'Fonts' ) = 0 then Result := GetPythonObject( Self.Fonts, 'Forms', 'TStrings' )
    else if CompareText( key, 'FormCount' ) = 0 then Result := VariantAsPyObject( Self.FormCount )
    else if CompareText( key, 'Imes' ) = 0 then Result := GetPythonObject( Self.Imes, 'Forms', 'TStrings' )
    else if CompareText( key, 'DefaultIme' ) = 0 then Result := VariantAsPyObject( Self.DefaultIme )
    else if CompareText( key, 'DefaultKbLayout' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'HKL' ); Result := nil; end
    else if CompareText( key, 'Height' ) = 0 then Result := VariantAsPyObject( Self.Height )
    else if CompareText( key, 'PixelsPerInch' ) = 0 then Result := VariantAsPyObject( Self.PixelsPerInch )
    else if CompareText( key, 'Width' ) = 0 then Result := VariantAsPyObject( Self.Width )
    else if CompareText( key, 'OnActiveControlChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnActiveFormChange' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TScreen_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TScreen;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( argSelf, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    // Check attribute
    Result := TScreen_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TScreen_WriteAttribute( Self : TScreen; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'ActiveControl' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ActiveCustomForm' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'ActiveForm' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'CustomFormCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Cursor' ) = 0 then begin
      Self.Cursor := TCursor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'DataModuleCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'MonitorCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DesktopHeight' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DesktopLeft' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DesktopTop' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DesktopWidth' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'IconFont' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TFont then begin
        Self.IconFont := TFont( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'IconFont', 'TFont' );
    end else if CompareText( key, 'Fonts' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'FormCount' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Imes' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DefaultIme' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DefaultKbLayout' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Height' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'PixelsPerInch' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Width' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'OnActiveControlChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnActiveControlChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScreen then
          with TPyScreen(Self) do
            OnActiveControlChange := EventOnActiveControlChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnActiveFormChange' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnActiveFormChange := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyScreen then
          with TPyScreen(Self) do
            OnActiveFormChange := EventOnActiveFormChange;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TScreen_DisableAlign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScreen;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( Self, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    realObj.DisableAlign;
    Result := ReturnNone;
  end;
end;

function TScreen_EnableAlign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScreen;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( Self, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    realObj.EnableAlign;
    Result := ReturnNone;
  end;
end;

function TScreen_Realign( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScreen;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( Self, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    realObj.Realign;
    Result := ReturnNone;
  end;
end;

function TScreen_CustomForms( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScreen;
  rslt : TCustomForm;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TScreen.CustomForms', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( Self, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    rslt := realObj.CustomForms[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Forms', 'TCustomForm' );
  end;
end;

function TScreen_Cursors( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScreen;
  rslt : HCURSOR;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TScreen.Cursors', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( Self, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    rslt := realObj.Cursors[ Integer(_argIndex) ];
    Result := VariantAsPyObject( rslt );
  end;
end;

function TScreen_DataModules( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScreen;
  rslt : TDataModule;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TScreen.DataModules', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( Self, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    rslt := realObj.DataModules[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Forms', 'TDataModule' );
  end;
end;

function TScreen_Monitors( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScreen;
  rslt : TMonitor;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TScreen.Monitors', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( Self, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    rslt := realObj.Monitors[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Forms', 'TMonitor' );
  end;
end;

function TScreen_Forms( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TScreen;
  rslt : TForm;
  _argIndex : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TScreen.Forms', [ 
                  @_argIndex       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TScreen) then begin
      ErrorWrongExpectedType( Self, 'TScreen' );
      Exit;
    end;
    realObj := TScreen(obj);
    rslt := realObj.Forms[ Integer(_argIndex) ];
    Result := GetPythonObject( rslt, 'Forms', 'TForm' );
  end;
end;

///////////// Functions for class TApplication //////////////////

function TApplication_Create( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  _argSelf : PPyObject;
  _argAOwner : PPyObject;
  _objAOwner : TComponent;
begin
  Result := nil;
  with GetPythonEngine do begin
    if PyArg_ParseTuple( Args, 'OO:TApplication.Create', [ @_argSelf,
                  @_argAOwner       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    DefInterfaceObject( Application, _argSelf, False );
    Result := _argSelf;
    Py_XIncRef( Result );
  end;
end;

function TApplication_GetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'Os', [@argSelf, @argKey]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( argSelf, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    // Check attribute
    Result := TApplication_ReadAttribute( realObj, argSelf, argKey );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      UnknownProperty( argSelf, argKey );
  end;
end;

function TApplication_ReadAttribute( Self : TApplication; argSelf : PPyObject; key : PChar ) : PPyObject;
begin
  with GetPythonEngine do begin
    if gTApplication.MethodCount > 0 then 
      Result := Py_FindMethod( gTApplication.MethodsData, argSelf, key)
    else Result := nil;
    if Assigned(Result) then Exit else PyErr_Clear;
    if CompareText( key, 'Properties') = 0 then Result := GetPropList( Self )
    else if CompareText( key, 'Active' ) = 0 then Result := VariantAsPyObject( Self.Active )
    else if CompareText( key, 'AllowTesting' ) = 0 then Result := VariantAsPyObject( Self.AllowTesting )
    else if CompareText( key, 'CurrentHelpFile' ) = 0 then Result := VariantAsPyObject( Self.CurrentHelpFile )
    else if CompareText( key, 'DialogHandle' ) = 0 then Result := VariantAsPyObject( Self.DialogHandle )
    else if CompareText( key, 'ExeName' ) = 0 then Result := VariantAsPyObject( Self.ExeName )
    else if CompareText( key, 'Handle' ) = 0 then Result := VariantAsPyObject( Self.Handle )
    else if CompareText( key, 'HelpFile' ) = 0 then Result := VariantAsPyObject( Self.HelpFile )
    else if CompareText( key, 'Hint' ) = 0 then Result := VariantAsPyObject( Self.Hint )
    else if CompareText( key, 'HintColor' ) = 0 then Result := VariantAsPyObject( Integer( Self.HintColor ) )
    else if CompareText( key, 'HintHidePause' ) = 0 then Result := VariantAsPyObject( Self.HintHidePause )
    else if CompareText( key, 'HintPause' ) = 0 then Result := VariantAsPyObject( Self.HintPause )
    else if CompareText( key, 'HintShortCuts' ) = 0 then Result := VariantAsPyObject( Self.HintShortCuts )
    else if CompareText( key, 'HintShortPause' ) = 0 then Result := VariantAsPyObject( Self.HintShortPause )
    else if CompareText( key, 'Icon' ) = 0 then Result := GetPythonObject( Self.Icon, 'Forms', 'TIcon' )
    else if CompareText( key, 'MainForm' ) = 0 then Result := GetPythonObject( Self.MainForm, 'Forms', 'TForm' )
    else if CompareText( key, 'BiDiMode' ) = 0 then Result := VariantAsPyObject( Integer( Self.BiDiMode ) )
    else if CompareText( key, 'ShowHint' ) = 0 then Result := VariantAsPyObject( Self.ShowHint )
    else if CompareText( key, 'ShowMainForm' ) = 0 then Result := VariantAsPyObject( Self.ShowMainForm )
    else if CompareText( key, 'Terminated' ) = 0 then Result := VariantAsPyObject( Self.Terminated )
    else if CompareText( key, 'Title' ) = 0 then Result := VariantAsPyObject( Self.Title )
    else if CompareText( key, 'UpdateFormatSettings' ) = 0 then Result := VariantAsPyObject( Self.UpdateFormatSettings )
    else if CompareText( key, 'UpdateMetricSettings' ) = 0 then Result := VariantAsPyObject( Self.UpdateMetricSettings )
    else if CompareText( key, 'OnActionExecute' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TActionEvent' ); Result := nil; end
    else if CompareText( key, 'OnActionUpdate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TActionEvent' ); Result := nil; end
    else if CompareText( key, 'OnActivate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnDeactivate' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnException' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TExceptionEvent' ); Result := nil; end
    else if CompareText( key, 'OnIdle' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TIdleEvent' ); Result := nil; end
    else if CompareText( key, 'OnHelp' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'THelpEvent' ); Result := nil; end
    else if CompareText( key, 'OnHint' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnMessage' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TMessageEvent' ); Result := nil; end
    else if CompareText( key, 'OnMinimize' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnRestore' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TNotifyEvent' ); Result := nil; end
    else if CompareText( key, 'OnShowHint' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TShowHintEvent' ); Result := nil; end
    else if CompareText( key, 'OnShortCut' ) = 0 then begin ErrorTypeNotHandled( argSelf, key, 'TShortCutEvent' ); Result := nil; end
    else Result := TComponent_ReadAttribute( Self, argSelf, key );
  end;
end;

function TApplication_SetAttr( Self, Args : PPyObject ) : PPyObject; cdecl; far;
var
  argSelf, argValue : PPyObject;
  argKey : PChar;
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Extract args
    if PyArg_ParseTuple( Args, 'OsO', [@argSelf, @argKey, @argValue]) = 0 then
      Exit;
    // Check Delphi object
    obj := GetObjectOf( argSelf );
    if not Assigned(obj) then begin
      ErrorNoObject( argSelf );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( argSelf, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    // Check attribute
    Result := TApplication_WriteAttribute( realObj, argSelf, argKey, argValue );
    // Check result
    if not Assigned(Result) and (PyErr_Occurred = nil) then
      Result := AddNewMember( argSelf, argKey, argValue );
  end;
end;

function TApplication_WriteAttribute( Self : TApplication; argSelf : PPyObject; key : PChar; value : PPyObject ) : PPyObject;
var
  obj : TObject;
begin
  Result := nil;
  obj := nil;
  with GetPythonEngine do begin
    if False then begin
    end else if CompareText( key, 'Active' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'AllowTesting' ) = 0 then begin
      Self.AllowTesting := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'CurrentHelpFile' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'DialogHandle' ) = 0 then begin
      Self.DialogHandle := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ExeName' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Handle' ) = 0 then begin
      Self.Handle := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HelpFile' ) = 0 then begin
      Self.HelpFile := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Hint' ) = 0 then begin
      Self.Hint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HintColor' ) = 0 then begin
      Self.HintColor := TColor(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HintHidePause' ) = 0 then begin
      Self.HintHidePause := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HintPause' ) = 0 then begin
      Self.HintPause := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HintShortCuts' ) = 0 then begin
      Self.HintShortCuts := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'HintShortPause' ) = 0 then begin
      Self.HintShortPause := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Icon' ) = 0 then begin
      obj := GetObjectOf(value);
      if obj is TIcon then begin
        Self.Icon := TIcon( obj );
        Result := PyInt_FromLong(0);
      end else ErrorWrongPropertyType( argSelf, obj, 'Icon', 'TIcon' );
    end else if CompareText( key, 'MainForm' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'BiDiMode' ) = 0 then begin
      Self.BiDiMode := TBiDiMode(PyObjectAsVariant( value ));
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ShowHint' ) = 0 then begin
      Self.ShowHint := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'ShowMainForm' ) = 0 then begin
      Self.ShowMainForm := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'Terminated' ) = 0 then begin
      ErrorPropReadOnly( argSelf, key );
    end else if CompareText( key, 'Title' ) = 0 then begin
      Self.Title := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'UpdateFormatSettings' ) = 0 then begin
      Self.UpdateFormatSettings := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'UpdateMetricSettings' ) = 0 then begin
      Self.UpdateMetricSettings := PyObjectAsVariant( value );
      Result := PyInt_FromLong(0);
    end else if CompareText( key, 'OnActionExecute' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnActionExecute := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnActionExecute := EventOnActionExecute;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnActionUpdate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnActionUpdate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnActionUpdate := EventOnActionUpdate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnActivate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnActivate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnActivate := EventOnActivate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnDeactivate' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnDeactivate := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnDeactivate := EventOnDeactivate;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnException' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnException := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnException := EventOnException;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnIdle' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnIdle := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnIdle := EventOnIdle;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnHelp' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnHelp := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnHelp := EventOnHelp;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnHint' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnHint := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnHint := EventOnHint;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMessage' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMessage := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnMessage := EventOnMessage;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnMinimize' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnMinimize := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnMinimize := EventOnMinimize;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnRestore' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnRestore := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnRestore := EventOnRestore;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnShowHint' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnShowHint := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnShowHint := EventOnShowHint;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else if CompareText( key, 'OnShortCut' ) = 0 then begin
      if Value = Py_None then begin
        Self.OnShortCut := nil;
        Result := AddNewMember( argSelf, key, value );
      end else if CheckMethod( Value ) then begin
        if Self is TPyApplication then
          with TPyApplication(Self) do
            OnShortCut := EventOnShortCut;
        Result := AddNewMember( argSelf, key, value );
      end else ErrorBadEventType( argSelf, key );
    end else Result := TComponent_WriteAttribute( Self, argSelf, key, value );
  end;
end;

function TApplication_BringToFront( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.BringToFront;
    Result := ReturnNone;
  end;
end;

function TApplication_ControlDestroyed( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  _argControl : PPyObject;
  _objControl : TControl;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TApplication.ControlDestroyed', [ 
                  @_argControl       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objControl := GetObjectOf( _argControl ) as TControl;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.ControlDestroyed( _objControl );
    Result := ReturnNone;
  end;
end;

function TApplication_CancelHint( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.CancelHint;
    Result := ReturnNone;
  end;
end;

function TApplication_CreateForm( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TApplication_CreateHandle( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.CreateHandle;
    Result := ReturnNone;
  end;
end;

function TApplication_ExecuteAction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Boolean;
  _argAction : PPyObject;
  _objAction : TBasicAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TApplication.ExecuteAction', [ 
                  @_argAction       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAction := GetObjectOf( _argAction ) as TBasicAction;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.ExecuteAction( _objAction );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TApplication_HandleException( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  _argSender : PPyObject;
  _objSender : TObject;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TApplication.HandleException', [ 
                  @_argSender       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objSender := GetObjectOf( _argSender ) as TObject;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.HandleException( _objSender );
    Result := ReturnNone;
  end;
end;

function TApplication_HandleMessage( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.HandleMessage;
    Result := ReturnNone;
  end;
end;

function TApplication_HelpCommand( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Boolean;
  _argCommand : Integer;
  _argData : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ii:TApplication.HelpCommand', [ 
                  @_argCommand,
                  @_argData       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.HelpCommand( Integer(_argCommand), Longint(_argData) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TApplication_HelpContext( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Boolean;
  _argContext : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'i:TApplication.HelpContext', [ 
                  @_argContext       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.HelpContext( THelpContext(_argContext) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TApplication_HelpJump( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Boolean;
  _argJumpID : PChar;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 's:TApplication.HelpJump', [ 
                  @_argJumpID       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.HelpJump( string(_argJumpID) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TApplication_HideHint( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.HideHint;
    Result := ReturnNone;
  end;
end;

function TApplication_HintMouseMessage( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TApplication_HookMainWindow( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TApplication_Initialize( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.Initialize;
    Result := ReturnNone;
  end;
end;

function TApplication_IsRightToLeft( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.IsRightToLeft;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TApplication_MessageBox( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Integer;
  _argText : PChar;
  _argCaption : PChar;
  _argFlags : Integer;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'ssi:TApplication.MessageBox', [ 
                  @_argText,
                  @_argCaption,
                  @_argFlags       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.MessageBox( PChar(_argText), PChar(_argCaption), Longint(_argFlags) );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TApplication_Minimize( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.Minimize;
    Result := ReturnNone;
  end;
end;

function TApplication_NormalizeAllTopMosts( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.NormalizeAllTopMosts;
    Result := ReturnNone;
  end;
end;

function TApplication_NormalizeTopMosts( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.NormalizeTopMosts;
    Result := ReturnNone;
  end;
end;

function TApplication_ProcessMessages( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.ProcessMessages;
    Result := ReturnNone;
  end;
end;

function TApplication_Restore( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.Restore;
    Result := ReturnNone;
  end;
end;

function TApplication_RestoreTopMosts( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.RestoreTopMosts;
    Result := ReturnNone;
  end;
end;

function TApplication_Run( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.Run;
    Result := ReturnNone;
  end;
end;

function TApplication_ShowException( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TApplication_Terminate( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    realObj.Terminate;
    Result := ReturnNone;
  end;
end;

function TApplication_UnhookMainWindow( Self, Args : PPyObject ) : PPyObject; cdecl;
begin
  Result := nil;
  with GetPythonEngine do begin
    Result := ReturnNone;
  end;
end;

function TApplication_UpdateAction( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Boolean;
  _argAction : PPyObject;
  _objAction : TBasicAction;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyArg_ParseTuple( Args, 'O:TApplication.UpdateAction', [ 
                  @_argAction       ] ) = 0 then
      begin
        Result := nil;
        Exit;
      end;
    _objAction := GetObjectOf( _argAction ) as TBasicAction;
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.UpdateAction( _objAction );
    Result := VariantAsPyObject( rslt );
  end;
end;

function TApplication_UseRightToLeftAlignment( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.UseRightToLeftAlignment;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TApplication_UseRightToLeftReading( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.UseRightToLeftReading;
    Result := VariantAsPyObject( rslt );
  end;
end;

function TApplication_UseRightToLeftScrollBar( Self, Args : PPyObject ) : PPyObject; cdecl;
var
  obj : TObject;
  realObj : TApplication;
  rslt : Boolean;
begin
  Result := nil;
  with GetPythonEngine do begin
    // Parsing of method args
    if PyErr_Occurred <> nil then
      begin
        Result := nil;
        Exit;
      end;
    // Check Delphi object
    obj := GetObjectOf( Self );
    if not Assigned(obj) then begin
      ErrorNoObject( Self );
      Exit;
    end;
    // Check object type
    if not( obj is TApplication) then begin
      ErrorWrongExpectedType( Self, 'TApplication' );
      Exit;
    end;
    realObj := TApplication(obj);
    rslt := realObj.UseRightToLeftScrollBar;
    Result := VariantAsPyObject( rslt );
  end;
end;

///////////// Initialization of the module ///////////

procedure TModule_Forms.Initialize;
begin
  // class TControlScrollBar
  AddMethod( 'CreateControlScrollBar', TControlScrollBar_Create, '' );
  AddMethod( 'ControlScrollBar_GetAttr', TControlScrollBar_GetAttr, '' );
  AddMethod( 'ControlScrollBar_SetAttr', TControlScrollBar_SetAttr, '' );
  gTControlScrollBar.AddMethod( 'Assign', TControlScrollBar_Assign, '' );
  gTControlScrollBar.AddMethod( 'ChangeBiDiPosition', TControlScrollBar_ChangeBiDiPosition, '' );
  gTControlScrollBar.AddMethod( 'IsScrollBarVisible', TControlScrollBar_IsScrollBarVisible, '' );
  // class TScrollingWinControl
  AddMethod( 'CreateScrollingWinControl', TScrollingWinControl_Create, '' );
  AddMethod( 'CreateParentedScrollingWinControl', TScrollingWinControl_CreateParented, '' );
  AddMethod( 'ScrollingWinControl_GetAttr', TScrollingWinControl_GetAttr, '' );
  AddMethod( 'ScrollingWinControl_SetAttr', TScrollingWinControl_SetAttr, '' );
  gTScrollingWinControl.AddMethod( 'Create', TScrollingWinControl_Create, '' );
  gTScrollingWinControl.AddMethod( 'DisableAutoRange', TScrollingWinControl_DisableAutoRange, '' );
  gTScrollingWinControl.AddMethod( 'EnableAutoRange', TScrollingWinControl_EnableAutoRange, '' );
  gTScrollingWinControl.AddMethod( 'ScrollInView', TScrollingWinControl_ScrollInView, '' );
  // class TScrollBox
  AddMethod( 'CreateScrollBox', TScrollBox_Create, '' );
  AddMethod( 'CreateParentedScrollBox', TScrollBox_CreateParented, '' );
  AddMethod( 'ScrollBox_GetAttr', TScrollBox_GetAttr, '' );
  AddMethod( 'ScrollBox_SetAttr', TScrollBox_SetAttr, '' );
  gTScrollBox.AddMethod( 'Create', TScrollBox_Create, '' );
  // class TCustomForm
  AddMethod( 'CreateCustomForm', TCustomForm_Create, '' );
  AddMethod( 'CreateNewCustomForm', TCustomForm_CreateNew, '' );
  AddMethod( 'CreateParentedCustomForm', TCustomForm_CreateParented, '' );
  AddMethod( 'CustomForm_GetAttr', TCustomForm_GetAttr, '' );
  AddMethod( 'CustomForm_SetAttr', TCustomForm_SetAttr, '' );
  gTCustomForm.AddMethod( 'Create', TCustomForm_Create, '' );
  gTCustomForm.AddMethod( 'CreateNew', TCustomForm_CreateNew, '' );
  gTCustomForm.AddMethod( 'AfterConstruction', TCustomForm_AfterConstruction, '' );
  gTCustomForm.AddMethod( 'BeforeDestruction', TCustomForm_BeforeDestruction, '' );
  gTCustomForm.AddMethod( 'Close', TCustomForm_Close, '' );
  gTCustomForm.AddMethod( 'CloseQuery', TCustomForm_CloseQuery, '' );
  gTCustomForm.AddMethod( 'DefaultHandler', TCustomForm_DefaultHandler, '' );
  gTCustomForm.AddMethod( 'DefocusControl', TCustomForm_DefocusControl, '' );
  gTCustomForm.AddMethod( 'Dock', TCustomForm_Dock, '' );
  gTCustomForm.AddMethod( 'FocusControl', TCustomForm_FocusControl, '' );
  gTCustomForm.AddMethod( 'GetFormImage', TCustomForm_GetFormImage, '' );
  gTCustomForm.AddMethod( 'Hide', TCustomForm_Hide, '' );
  gTCustomForm.AddMethod( 'IsShortCut', TCustomForm_IsShortCut, '' );
  gTCustomForm.AddMethod( 'MouseWheelHandler', TCustomForm_MouseWheelHandler, '' );
  gTCustomForm.AddMethod( 'Print', TCustomForm_Print, '' );
  gTCustomForm.AddMethod( 'Release', TCustomForm_Release, '' );
  gTCustomForm.AddMethod( 'SendCancelMode', TCustomForm_SendCancelMode, '' );
  gTCustomForm.AddMethod( 'SetFocus', TCustomForm_SetFocus, '' );
  gTCustomForm.AddMethod( 'SetFocusedControl', TCustomForm_SetFocusedControl, '' );
  gTCustomForm.AddMethod( 'Show', TCustomForm_Show, '' );
  gTCustomForm.AddMethod( 'ShowModal', TCustomForm_ShowModal, '' );
  gTCustomForm.AddMethod( 'WantChildKey', TCustomForm_WantChildKey, '' );
  // class TCustomActiveForm
  AddMethod( 'CreateCustomActiveForm', TCustomActiveForm_Create, '' );
  AddMethod( 'CreateNewCustomActiveForm', TCustomActiveForm_CreateNew, '' );
  AddMethod( 'CreateParentedCustomActiveForm', TCustomActiveForm_CreateParented, '' );
  AddMethod( 'CustomActiveForm_GetAttr', TCustomActiveForm_GetAttr, '' );
  AddMethod( 'CustomActiveForm_SetAttr', TCustomActiveForm_SetAttr, '' );
  gTCustomActiveForm.AddMethod( 'Create', TCustomActiveForm_Create, '' );
  gTCustomActiveForm.AddMethod( 'WantChildKey', TCustomActiveForm_WantChildKey, '' );
  // class TForm
  AddMethod( 'CreateForm', TForm_Create, '' );
  AddMethod( 'CreateNewForm', TForm_CreateNew, '' );
  AddMethod( 'CreateParentedForm', TForm_CreateParented, '' );
  AddMethod( 'Form_GetAttr', TForm_GetAttr, '' );
  AddMethod( 'Form_SetAttr', TForm_SetAttr, '' );
  gTForm.AddMethod( 'ArrangeIcons', TForm_ArrangeIcons, '' );
  gTForm.AddMethod( 'Cascade', TForm_Cascade, '' );
  gTForm.AddMethod( 'Next', TForm_Next, '' );
  gTForm.AddMethod( 'Previous', TForm_Previous, '' );
  gTForm.AddMethod( 'Tile', TForm_Tile, '' );
  // class TCustomDockForm
  AddMethod( 'CreateCustomDockForm', TCustomDockForm_Create, '' );
  AddMethod( 'CreateNewCustomDockForm', TCustomDockForm_CreateNew, '' );
  AddMethod( 'CreateParentedCustomDockForm', TCustomDockForm_CreateParented, '' );
  AddMethod( 'CustomDockForm_GetAttr', TCustomDockForm_GetAttr, '' );
  AddMethod( 'CustomDockForm_SetAttr', TCustomDockForm_SetAttr, '' );
  gTCustomDockForm.AddMethod( 'Create', TCustomDockForm_Create, '' );
  // class TDataModule
  AddMethod( 'CreateDataModule', TDataModule_Create, '' );
  AddMethod( 'CreateNewDataModule', TDataModule_CreateNew, '' );
  AddMethod( 'DataModule_GetAttr', TDataModule_GetAttr, '' );
  AddMethod( 'DataModule_SetAttr', TDataModule_SetAttr, '' );
  gTDataModule.AddMethod( 'Create', TDataModule_Create, '' );
  gTDataModule.AddMethod( 'CreateNew', TDataModule_CreateNew, '' );
  gTDataModule.AddMethod( 'AfterConstruction', TDataModule_AfterConstruction, '' );
  gTDataModule.AddMethod( 'BeforeDestruction', TDataModule_BeforeDestruction, '' );
  // class TMonitor
  AddMethod( 'CreateMonitor', TMonitor_Create, '' );
  AddMethod( 'Monitor_GetAttr', TMonitor_GetAttr, '' );
  AddMethod( 'Monitor_SetAttr', TMonitor_SetAttr, '' );
  // class TScreen
  AddMethod( 'CreateScreen', TScreen_Create, '' );
  AddMethod( 'Screen_GetAttr', TScreen_GetAttr, '' );
  AddMethod( 'Screen_SetAttr', TScreen_SetAttr, '' );
  gTScreen.AddMethod( 'Create', TScreen_Create, '' );
  gTScreen.AddMethod( 'DisableAlign', TScreen_DisableAlign, '' );
  gTScreen.AddMethod( 'EnableAlign', TScreen_EnableAlign, '' );
  gTScreen.AddMethod( 'Realign', TScreen_Realign, '' );
  gTScreen.AddMethod( 'CustomForms', TScreen_CustomForms, '' );
  gTScreen.AddMethod( 'Cursors', TScreen_Cursors, '' );
  gTScreen.AddMethod( 'DataModules', TScreen_DataModules, '' );
  gTScreen.AddMethod( 'Monitors', TScreen_Monitors, '' );
  gTScreen.AddMethod( 'Forms', TScreen_Forms, '' );
  // class TApplication
  AddMethod( 'CreateApplication', TApplication_Create, '' );
  AddMethod( 'Application_GetAttr', TApplication_GetAttr, '' );
  AddMethod( 'Application_SetAttr', TApplication_SetAttr, '' );
  gTApplication.AddMethod( 'Create', TApplication_Create, '' );
  gTApplication.AddMethod( 'BringToFront', TApplication_BringToFront, '' );
  gTApplication.AddMethod( 'ControlDestroyed', TApplication_ControlDestroyed, '' );
  gTApplication.AddMethod( 'CancelHint', TApplication_CancelHint, '' );
  gTApplication.AddMethod( 'CreateForm', TApplication_CreateForm, '' );
  gTApplication.AddMethod( 'CreateHandle', TApplication_CreateHandle, '' );
  gTApplication.AddMethod( 'ExecuteAction', TApplication_ExecuteAction, '' );
  gTApplication.AddMethod( 'HandleException', TApplication_HandleException, '' );
  gTApplication.AddMethod( 'HandleMessage', TApplication_HandleMessage, '' );
  gTApplication.AddMethod( 'HelpCommand', TApplication_HelpCommand, '' );
  gTApplication.AddMethod( 'HelpContext', TApplication_HelpContext, '' );
  gTApplication.AddMethod( 'HelpJump', TApplication_HelpJump, '' );
  gTApplication.AddMethod( 'HideHint', TApplication_HideHint, '' );
  gTApplication.AddMethod( 'HintMouseMessage', TApplication_HintMouseMessage, '' );
  gTApplication.AddMethod( 'HookMainWindow', TApplication_HookMainWindow, '' );
  gTApplication.AddMethod( 'Initialize', TApplication_Initialize, '' );
  gTApplication.AddMethod( 'IsRightToLeft', TApplication_IsRightToLeft, '' );
  gTApplication.AddMethod( 'MessageBox', TApplication_MessageBox, '' );
  gTApplication.AddMethod( 'Minimize', TApplication_Minimize, '' );
  gTApplication.AddMethod( 'NormalizeAllTopMosts', TApplication_NormalizeAllTopMosts, '' );
  gTApplication.AddMethod( 'NormalizeTopMosts', TApplication_NormalizeTopMosts, '' );
  gTApplication.AddMethod( 'ProcessMessages', TApplication_ProcessMessages, '' );
  gTApplication.AddMethod( 'Restore', TApplication_Restore, '' );
  gTApplication.AddMethod( 'RestoreTopMosts', TApplication_RestoreTopMosts, '' );
  gTApplication.AddMethod( 'Run', TApplication_Run, '' );
  gTApplication.AddMethod( 'ShowException', TApplication_ShowException, '' );
  gTApplication.AddMethod( 'Terminate', TApplication_Terminate, '' );
  gTApplication.AddMethod( 'UnhookMainWindow', TApplication_UnhookMainWindow, '' );
  gTApplication.AddMethod( 'UpdateAction', TApplication_UpdateAction, '' );
  gTApplication.AddMethod( 'UseRightToLeftAlignment', TApplication_UseRightToLeftAlignment, '' );
  gTApplication.AddMethod( 'UseRightToLeftReading', TApplication_UseRightToLeftReading, '' );
  gTApplication.AddMethod( 'UseRightToLeftScrollBar', TApplication_UseRightToLeftScrollBar, '' );
  inherited;
end;

end.
